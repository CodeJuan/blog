<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Continuous Learning</title>
  <subtitle>浮云一别后，流水十年间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.decbug.com/"/>
  <updated>2017-04-01T14:11:35.413Z</updated>
  <id>http://blog.decbug.com/</id>
  
  <author>
    <name>CodeJuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云计算网络安全</title>
    <link href="http://blog.decbug.com/2017/03/03/cloud_network_security/"/>
    <id>http://blog.decbug.com/2017/03/03/cloud_network_security/</id>
    <published>2017-03-02T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>近日关于云计算安全的问题，闹的沸沸扬扬。某不才，也算是云计算入门人士，便结合自身经历分析一番。</p>
<a id="more"></a>
<h1 id="也曾被黑过"><a href="#也曾被黑过" class="headerlink" title="也曾被黑过"></a>也曾被黑过</h1><p>当时用的阿里云华北1，只有经典网络。那时候很天真，以为即使是经典网络，那么也是租户隔离的。为了便于几台机器互相调用，于是把安全组设置为内网入，所有协议，所有IP，所有端口都允许。</p>
<p>然而几天以后，某个机器无法SSH上去，通过vnc一看，不得了，竟然内核都被人改了。当时百思不得其解，我这个机器完全没有连外网啊，怎么会被黑呢？怎么会呢？</p>
<p>后来才知道经典网络是互通的，相互之间的隔离是通过安全组。默认的安全组是全部拒绝的，如果不是我手贱，就不会那么容易被黑。</p>
<h1 id="也谈VPC"><a href="#也谈VPC" class="headerlink" title="也谈VPC"></a>也谈VPC</h1><p>具体细节不谈了，之前也看过VxLan的原理。如果想深入，看看neurtron的组网就明白了，net，subnet，port</p>
<p>所谓VPC，就是隔离隔离隔离，简单来说，就是对于虚拟机所看到的网络，和别人的网络是不通的。如果当时用的VPC，就已经和其他租户隔离了，被黑的概率大为降低。</p>
<h1 id="阿里云容器服务"><a href="#阿里云容器服务" class="headerlink" title="阿里云容器服务"></a>阿里云容器服务</h1><p>分析清除了之前被黑的原因，便看了看我阿里云下的安全组，发现竟然有两条不是我自己创的。看了下名字以及创建时间，想起来是之前用容器服务的时候创建的。</p>
<p>再打开规则一看，一看吓一跳</p>
<table>
<thead>
<tr>
<th>授权策略</th>
<th>协议类型</th>
<th>端口范围</th>
<th>授权类型</th>
<th>授权对象</th>
<th>优先级</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>允许</td>
<td>全部</td>
<td>-1/-1</td>
<td>地址段访问</td>
<td>0.0.0.0/0</td>
<td>1</td>
<td>克隆 删除</td>
</tr>
</tbody>
</table>
<p>竟然是全部允许。后来联系阿里云容器服务的易立大侠，报告这个安全问题，得知这个问题早已修复。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>能用VPC就用VPC，虽然会稍微复杂一点，但安全性大为提高。</p>
<p>另外再问一句，为啥阿里云华北1只有经典网络？就因为比其他region便宜10%？</p>
<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p><a href="https://www.v2ex.com/t/343762?from=groupmessage&amp;isappinstalled=0" target="_blank" rel="external">云舒：给小白的租户隔离科普文</a><br><a href="http://weibo.com/ttarticle/p/show?id=2309404079443999097225" target="_blank" rel="external">左耳朵耗子：科普一下公有云的网络</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日关于云计算安全的问题，闹的沸沸扬扬。某不才，也算是云计算入门人士，便结合自身经历分析一番。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="cloud" scheme="http://blog.decbug.com/tags/cloud/"/>
    
      <category term="security" scheme="http://blog.decbug.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Run a full OpenStack in a LXD container</title>
    <link href="http://blog.decbug.com/2017/02/26/openstack_in_lxc/"/>
    <id>http://blog.decbug.com/2017/02/26/openstack_in_lxc/</id>
    <published>2017-02-25T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.417Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于lxc容器特别像虚拟机的特点，rackspace，都有把openstack部署到lxc容器里的实践，恰好lxc也有类似教程，打算自己跑一遍，看看是怎样一种体验</p>
<p>how to run a full OpenStack, using LXD containers instead of VMs and running all of this inside a LXD container (nesting!).</p>
<a id="more"></a>
<h1 id="安装lxd"><a href="#安装lxd" class="headerlink" title="安装lxd"></a>安装lxd</h1><p>还是ubuntu好，直接apt就行了，不像在centos上，需要从头开始编译liblxc,lxd<a href="https://github.com/CodeJuan/lxc_lxd" target="_blank" rel="external">试验记录</a>。更可怕的是，AppArmor/SeLinux/Seccomp/user namespace/都需要另外安装，如果不安装，就需要在编译liblxc时disable掉</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt -t trusty-backports install lxd</span><br></pre></td></tr></table></figure>
<p>安装完成后，查看版本<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i3<span class="variable">@i3</span><span class="symbol">:~</span><span class="variable">$ </span>lxc --version</span><br><span class="line"><span class="number">2.0</span>.<span class="number">8</span></span><br><span class="line">i3<span class="variable">@i3</span><span class="symbol">:~</span><span class="variable">$ </span>lxd --version</span><br><span class="line"><span class="number">2.0</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<h2 id="安装ZFS"><a href="#安装ZFS" class="headerlink" title="安装ZFS"></a>安装ZFS</h2><table>
<thead>
<tr>
<th style="text-align:left">Feature</th>
<th style="text-align:left">Directory</th>
<th style="text-align:left">Btrfs</th>
<th style="text-align:left">LVM</th>
<th style="text-align:left">ZFS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Optimized image storage</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">Optimized container creation</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">Optimized snapshot creation</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">Optimized image transfer</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">Optimized container transfer</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">Copy on write</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">Block based</td>
<td style="text-align:left">no</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">Instant cloning</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">Nesting support</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">no</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">Restore from older snapshots (not latest)</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">Storage quotas</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
</tr>
</tbody>
</table>
<p>lxc支持的存储后端，看来ZFS不错，打算用他</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">add</span>-repository <span class="keyword">pp</span><span class="variable">a:zfs</span>-native/stable</span><br><span class="line">sudo apt <span class="keyword">update</span></span><br><span class="line">sudo apt install ubuntu-zfs</span><br></pre></td></tr></table></figure>
<h2 id="init-lxd"><a href="#init-lxd" class="headerlink" title="init lxd"></a>init lxd</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> lxd init</span><br></pre></td></tr></table></figure>
<p>需要注意：如果是想在嵌套容器里跑openstack，那么网络只选择IPV4和存储后端用DIR</p>
<p>完成后<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$brctl</span> show</span><br><span class="line">lxdbr<span class="number">0</span>		<span class="number">8000.000000000000</span>	no</span><br></pre></td></tr></table></figure></p>
<p>多了一个linux桥</p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc launch ubuntu:16.04 first</span><br><span class="line"></span><br><span class="line"># 进入到容器</span><br><span class="line">sudo lxc exec first -- bash</span><br><span class="line"></span><br><span class="line">root@first:~# curl aliyun.com</span><br><span class="line"><span class="doctype">&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span>301 Moved Permanently<span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">bgcolor</span>=<span class="value">"white"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>301 Moved Permanently<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>The requested resource has been assigned a new permanent URI.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">hr</span>/&gt;</span>Powered by Tengine/Aserver<span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="resource-control"><a href="#resource-control" class="headerlink" title="resource control"></a>resource control</h2><p><a href="https://stgraber.org/2016/03/26/lxd-2-0-resource-control-412/" target="_blank" rel="external">https://stgraber.org/2016/03/26/lxd-2-0-resource-control-412/</a></p>
<h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i3<span class="variable">@i3</span><span class="symbol">:~</span><span class="variable">$ </span>sudo lxc config set first limits.cpu <span class="number">1</span></span><br><span class="line">i3<span class="variable">@i3</span><span class="symbol">:~</span><span class="variable">$ </span>sudo lxc exec first -- bash</span><br><span class="line">root<span class="variable">@first</span><span class="symbol">:~</span><span class="comment"># cat /proc/cpuinfo</span></span><br><span class="line">processor	<span class="symbol">:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">只能看到一个核</span><br></pre></td></tr></table></figure>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@first:~# cat /<span class="keyword">proc</span>/meminfo<span class="symbol"></span><br><span class="line">MemTotal:</span>       16095260<span class="symbol"> kB</span></span><br><span class="line"><span class="symbol"></span><br><span class="line">i3@i3:~$</span> sudo<span class="symbol"> lxc</span> config<span class="symbol"> set</span> first<span class="symbol"> limits.memory</span> 512MB<span class="symbol"></span><br><span class="line">i3@i3:~$</span> sudo<span class="symbol"> lxc</span> exec<span class="symbol"> first</span> --<span class="symbol"> bash</span></span><br><span class="line">root@first:~#<span class="symbol"> cat</span> /<span class="keyword">proc</span>/meminfo<span class="symbol"></span><br><span class="line">MemTotal:</span>         524288<span class="symbol"> kB</span></span><br></pre></td></tr></table></figure>
<h1 id="openstack"><a href="#openstack" class="headerlink" title="openstack"></a>openstack</h1><h2 id="容器已经成功创建，开始尝试openstack"><a href="#容器已经成功创建，开始尝试openstack" class="headerlink" title="容器已经成功创建，开始尝试openstack"></a>容器已经成功创建，开始尝试openstack</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc <span class="keyword">init</span> ubuntu:<span class="number">16.04</span> openstack -<span class="built_in">c</span> security.privileged=<span class="literal">true</span> -<span class="built_in">c</span> security.nesting=<span class="literal">true</span> -<span class="built_in">c</span> <span class="string">"linux.kernel_modules=iptable_nat, ip6table_nat, ebtables, openvswitch, nbd"</span></span><br><span class="line">printf <span class="string">"lxc.cap.drop=\nlxc.aa_profile=unconfined\n"</span> | sudo lxc config <span class="keyword">set</span> openstack raw.lxc -</span><br><span class="line">sudo lxc config device add openstack mem unix-char path=/dev/mem</span><br><span class="line">sudo lxc start openstack</span><br></pre></td></tr></table></figure>
<h2 id="可以看到openstack容器已经运行"><a href="#可以看到openstack容器已经运行" class="headerlink" title="可以看到openstack容器已经运行"></a>可以看到openstack容器已经运行</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">i3@i3:~$ sudo lxc list</span><br><span class="line">+-----------+---------+----------------------+------+------------+-----------+</span></span><br><span class="line"><span class="header">|   NAME    |  STATE  |         IPV4         | IPV6 |    TYPE    | SNAPSHOTS |</span><br><span class="line">+-----------+---------+----------------------+------+------------+-----------+</span></span><br><span class="line"><span class="header">| openstack | RUNNING | 10.84.103.125 (eth0) |      | PERSISTENT | 0         |</span><br><span class="line">+-----------+---------+----------------------+------+------------+-----------+</span></span><br></pre></td></tr></table></figure>
<h2 id="安装juju"><a href="#安装juju" class="headerlink" title="安装juju"></a>安装juju</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc <span class="built_in">exec</span> openstack -- apt update</span><br><span class="line">sudo lxc <span class="built_in">exec</span> openstack -- apt dist-upgrade -y</span><br><span class="line">sudo lxc <span class="built_in">exec</span> openstack -- apt install squashfuse -y</span><br><span class="line">sudo lxc <span class="built_in">exec</span> openstack -- ln <span class="operator">-s</span> /bin/<span class="literal">true</span> /usr/<span class="built_in">local</span>/bin/udevadm</span><br><span class="line">sudo lxc <span class="built_in">exec</span> openstack -- snap install conjure-up --classic</span><br></pre></td></tr></table></figure>
<p>初始化容器里的lxd<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc exec openstack <span class="comment">-- lxd init</span></span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://stgraber.org/2016/10/26/lxd-2-0-lxd-and-openstack-1112/" target="_blank" rel="external">https://stgraber.org/2016/10/26/lxd-2-0-lxd-and-openstack-1112/</a><br><a href="https://stgraber.org/2016/03/15/lxd-2-0-installing-and-configuring-lxd-212/" target="_blank" rel="external">https://stgraber.org/2016/03/15/lxd-2-0-installing-and-configuring-lxd-212/</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鉴于lxc容器特别像虚拟机的特点，rackspace，都有把openstack部署到lxc容器里的实践，恰好lxc也有类似教程，打算自己跑一遍，看看是怎样一种体验&lt;/p&gt;
&lt;p&gt;how to run a full OpenStack, using LXD containers instead of VMs and running all of this inside a LXD container (nesting!).&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>cloud-init</title>
    <link href="http://blog.decbug.com/2017/02/24/cloud-init/"/>
    <id>http://blog.decbug.com/2017/02/24/cloud-init/</id>
    <published>2017-02-23T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>刚创出来的虚拟机，要如何设置初始密码？如何添加环境变量？如何进行一系列的预置操作？<br>答案就是cloud-init。<br>当前正在搞openstack+lxc，也需要在创容器的时候注入一些信息，比如初始密码，开启SSH密码登录，允许root等等，就顺手记录cloud-init一下。</p>
<a id="more"></a>
<p>对于open stack来说，cloud-init可以通过两种方式获取数据</p>
<ol>
<li>config drive</li>
<li>通过meta-data服务获取</li>
</ol>
<h1 id="config-drive"><a href="#config-drive" class="headerlink" title="config drive"></a>config drive</h1><p>大概原理及流程</p>
<ol>
<li>生成相关的meta-data.json, user-data</li>
<li>制作iso9xxx格式的iso</li>
<li>挂载到/dev/vdb</li>
<li>cloud-init配置datasource为config drive</li>
<li>cloud-init读取，进行配置</li>
</ol>
<h1 id="meta-data"><a href="#meta-data" class="headerlink" title="meta-data"></a>meta-data</h1><ol>
<li>nova有个meta-data服务</li>
<li>创虚拟机的时候，配置一条路由169.254.169.254</li>
<li>cloud-init配置datasource为openstack</li>
<li>从<a href="http://169.254.169.254/openstack获取meta-data.json" target="_blank" rel="external">http://169.254.169.254/openstack获取meta-data.json</a></li>
<li>进行配置</li>
</ol>
<h1 id="user-data"><a href="#user-data" class="headerlink" title="user-data"></a>user-data</h1><p>nova boot –user-data config.txt</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#cloud-config</span></span><br><span class="line"><span class="label">chpasswd:</span></span><br><span class="line">  list: |</span><br><span class="line">    root:root</span><br><span class="line">    abc:password1</span><br><span class="line"><span class="label">pwauth:</span> True</span><br><span class="line"><span class="label">sshpasswd:</span> yes</span><br><span class="line"></span><br><span class="line"><span class="label">writefiles:</span></span><br><span class="line">  PermitRoot: yes</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://help.ubuntu.com/community/CloudInit" target="_blank" rel="external">https://help.ubuntu.com/community/CloudInit</a><br><a href="http://www.ibm.com/developerworks/cn/cloud/library/1509_liukg_openstackmeta/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/cloud/library/1509_liukg_openstackmeta/index.html</a><br><a href="http://www.chenshake.com/openstack-mirror-and-password/" target="_blank" rel="external">http://www.chenshake.com/openstack-mirror-and-password/</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚创出来的虚拟机，要如何设置初始密码？如何添加环境变量？如何进行一系列的预置操作？&lt;br&gt;答案就是cloud-init。&lt;br&gt;当前正在搞openstack+lxc，也需要在创容器的时候注入一些信息，比如初始密码，开启SSH密码登录，允许root等等，就顺手记录cloud-init一下。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="openstack" scheme="http://blog.decbug.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>lxd,lxc,nova-lxd</title>
    <link href="http://blog.decbug.com/2017/02/11/nova-lxd-lxc/"/>
    <id>http://blog.decbug.com/2017/02/11/nova-lxd-lxc/</id>
    <published>2017-02-10T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.417Z</updated>
    
    <content type="html"><![CDATA[<p>分析一下lxc, lxd, nova-lxd的关系以及源码</p>
<ul>
<li><a href="https://github.com/openstack/nova-lxd" target="_blank" rel="external">nova-lxd</a>,An OpenStack Compute driver for LXD</li>
<li><a href="https://github.com/lxc/lxd" target="_blank" rel="external">lxd</a>，lxd daemon和lxd client</li>
<li><a href="https://github.com/lxc/lxc" target="_blank" rel="external">lxc</a>，liblxc和lxc-tools</li>
</ul>
<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">                              +---------------+</span><br><span class="line">+----------+                  |               |</span><br><span class="line">| lxc      |                  |   nova-lxd    |</span><br><span class="line">| lxd-client+---+      +------+               |</span><br><span class="line">+----------+    |      |      |               |</span><br><span class="line">                |      |      +---------------+</span><br><span class="line">                |      |</span><br><span class="line">                |      |</span><br><span class="line">             +--v------v---------+</span><br><span class="line">             |     lxd           |</span><br><span class="line">             |                   |</span><br><span class="line">             |Daemon based on    |</span><br><span class="line">             |liblxc offering    |</span><br><span class="line">             |a REST API         |                  +-------------------------+</span><br><span class="line">             |to manage containers                  |                         |</span><br><span class="line">             +--------+----------+                  |   lxc/lxc               |</span><br><span class="line">                      |                             |   tools to              |</span><br><span class="line">                      |                             |   manage containers     |</span><br><span class="line">                      |                             |                         |</span><br><span class="line">             +--------v----------+                  |                         |</span><br><span class="line">             |                   |                  |                         |</span><br><span class="line">             |      go-lxc./v2   |                  +--------+----------------+</span><br><span class="line">             |                   |                           |</span><br><span class="line">             |                   |                           |</span><br><span class="line">             |                   |                           |</span><br><span class="line">             +----------+--------+                           |</span><br><span class="line">                        |                                    |</span><br><span class="line">                        |                                    |</span><br><span class="line">                        |                                    |</span><br><span class="line">                        |                                    |</span><br><span class="line">              +---------v------------------------------------v---------+</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                    liblxc.so                           |</span><br><span class="line">              |                                                        |</span><br><span class="line">              +-------------------------+------------------------------+</span><br><span class="line">                                        |</span><br><span class="line">                                        |</span><br><span class="line">                                        |</span><br><span class="line">              +-------------------------v------------------------------+</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                kernel                                  |</span><br><span class="line">              |                namespace, cgroups                      |</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                                                        |</span><br><span class="line">              +--------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="lxd分析"><a href="#lxd分析" class="headerlink" title="lxd分析"></a>lxd分析</h1><p>包含两部分</p>
<ul>
<li>lxd, 类似docker daemon，对外提供restful api</li>
<li>lxc, lxd daemon的客户端</li>
</ul>
<p>lxd daemon通过<code>go lxc v2</code>来调用<code>liblxc.so</code>，其中用到了cgo以及lxc的头文件，所以要先编译liblxc</p>
<h1 id="lxc-tools"><a href="#lxc-tools" class="headerlink" title="lxc-tools"></a>lxc-tools</h1><p><a href="(https://github.com/lxc/lxc/tree/master/src/lxc/tools">lxc-tools</a>)只是<a href="https://github.com/lxc/lxc" target="_blank" rel="external">lxc/lxc</a>的一部分，提供可执行文件用于管理lxc容器。<br>lxc/lxc最重要的部分还是liblxc.so</p>
<h1 id="nova-lxd"><a href="#nova-lxd" class="headerlink" title="nova-lxd"></a>nova-lxd</h1><p>nova-compute的一个driver，类似以前看过的nova-docker</p>
<ul>
<li>相比docker，lxc的行为上更像虚拟机，所以更适合用来和openstack一起玩<a href="http://blog.decbug.com/2017/02/11/lxc_docker/">http://blog.decbug.com/2017/02/11/lxc_docker/</a></li>
<li>北向: 提供spawn, plug-network等接口给nova-compute</li>
<li>南向: 调用lxd daemon管理容器</li>
</ul>
<h2 id="基本功能及流程"><a href="#基本功能及流程" class="headerlink" title="基本功能及流程"></a>基本功能及流程</h2><h3 id="创容器"><a href="#创容器" class="headerlink" title="创容器"></a>创容器</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check to see if LXD already has a copy of the image. If not,</span></span><br><span class="line"><span class="comment"># fetch it.</span></span><br><span class="line">_sync_glance_image_to_lxd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plug in the network</span></span><br><span class="line">plug_vifs(instance, network_info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the profile(including devices, flavor, )</span></span><br><span class="line">container = self.client.containers.create(</span><br><span class="line">                container_config, wait=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># start</span></span><br><span class="line">container.start(wait=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">image = IMAGE_API.get(context, image_ref)</span><br><span class="line">IMAGE_API.download(context, image_ref, dest_path=image_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate metadata.yaml</span></span><br><span class="line">            metadata = &#123;</span><br><span class="line">                <span class="string">'architecture'</span>: image.get(</span><br><span class="line">                    <span class="string">'hw_architecture'</span>, obj_fields.Architecture.from_host()),</span><br><span class="line">                <span class="string">'creation_date'</span>: int(os.stat(image_file).st_ctime)&#125;</span><br><span class="line">            metadata_yaml = json.dumps(</span><br><span class="line">                metadata, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>,</span><br><span class="line">                separators=(<span class="string">','</span>, <span class="string">': '</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment"># add metadata.yaml to tar.gz</span></span><br><span class="line">            tarball = tarfile.open(manifest_file, <span class="string">"w:gz"</span>)</span><br><span class="line">            tarinfo = tarfile.TarInfo(name=<span class="string">'metadata.yaml'</span>)</span><br><span class="line">            tarinfo.size = len(metadata_yaml)</span><br><span class="line">            tarball.addfile(tarinfo, io.BytesIO(metadata_yaml))</span><br><span class="line">            tarball.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># upload tar.gz to local lxd image registry</span></span><br><span class="line">image = client.images.create(</span><br><span class="line">                        image.read(), metadata=manifest.read(),</span><br><span class="line">                        wait=<span class="keyword">True</span>)</span><br><span class="line">            image.add_alias(image_ref, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p><a href="https://github.com/openstack/nova-lxd/blob/master/nova/virt/lxd/vif.py" target="_blank" rel="external">https://github.com/openstack/nova-lxd/blob/master/nova/virt/lxd/vif.py</a></p>
<ul>
<li>plug</li>
<li>unplug</li>
<li>brctl创建linux桥，以及addif</li>
<li>ovs-vsctl创建ovs桥，以及add port(pvo pvi)</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析一下lxc, lxd, nova-lxd的关系以及源码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/openstack/nova-lxd&quot;&gt;nova-lxd&lt;/a&gt;,An OpenStack Compute driver for LXD&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lxc/lxd&quot;&gt;lxd&lt;/a&gt;，lxd daemon和lxd client&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lxc/lxc&quot;&gt;lxc&lt;/a&gt;，liblxc和lxc-tools&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;关系&quot;&gt;&lt;a href=&quot;#关系&quot; class=&quot;headerlink&quot; title=&quot;关系&quot;&gt;&lt;/a&gt;关系&lt;/h1&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;                              +---------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------+                  |               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| lxc      |                  |   nova-lxd    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| lxd-client+---+      +------+               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------+    |      |      |               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                |      |      +---------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                |      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                |      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             +--v------v---------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |     lxd           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                   |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |Daemon based on    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |liblxc offering    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |a REST API         |                  +-------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |to manage containers                  |                         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             +--------+----------+                  |   lxc/lxc               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      |                             |   tools to              |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      |                             |   manage containers     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      |                             |                         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             +--------v----------+                  |                         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                   |                  |                         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |      go-lxc./v2   |                  +--------+----------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                   |                           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                   |                           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                   |                           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             +----------+--------+                           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        |                                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        |                                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        |                                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        |                                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              +---------v------------------------------------v---------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                    liblxc.so                           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              +-------------------------+------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              +-------------------------v------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                kernel                                  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                namespace, cgroups                      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              +--------------------------------------------------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="container" scheme="http://blog.decbug.com/tags/container/"/>
    
      <category term="lxc" scheme="http://blog.decbug.com/tags/lxc/"/>
    
      <category term="openstack" scheme="http://blog.decbug.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>LXC,docker</title>
    <link href="http://blog.decbug.com/2017/02/11/lxc_docker/"/>
    <id>http://blog.decbug.com/2017/02/11/lxc_docker/</id>
    <published>2017-02-10T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.417Z</updated>
    
    <content type="html"><![CDATA[<p>docker偏向于应用，LXC偏向于资源，其产品形态更像是一台虚拟机，所以其有个名字叫系统容器/机器容器。<br>然而，在当前docker大势已成，虚拟机经久不衰的形势下，lxc的优势和劣势都有哪些？</p>
<a id="more"></a>
<h1 id="LXC-vs-VM"><a href="#LXC-vs-VM" class="headerlink" title="LXC vs. VM"></a>LXC vs. VM</h1><table>
<thead>
<tr>
<th>对比</th>
<th>LXC</th>
<th>VM</th>
</tr>
</thead>
<tbody>
<tr>
<td>hyper层</td>
<td>用namespace,cgroup,无</td>
<td>有，KVM/XEN</td>
</tr>
<tr>
<td>内核</td>
<td>共用host</td>
<td>有guest</td>
</tr>
<tr>
<td>启动</td>
<td>秒</td>
<td>分</td>
</tr>
</tbody>
</table>
<p>可以说，docker的优点，LXC都有，然而其形态却更像虚拟机</p>
<h1 id="LXC-vs-docker"><a href="#LXC-vs-docker" class="headerlink" title="LXC vs. docker"></a>LXC vs. docker</h1><table>
<thead>
<tr>
<th>对比</th>
<th>LXC</th>
<th>docker</th>
</tr>
</thead>
<tbody>
<tr>
<td>init进程</td>
<td>有systemd作为init进程</td>
<td>entrypoint或cmd里的进程，其实就是业务进程，如果业务进程挂了，容器也跟着消失</td>
</tr>
<tr>
<td>行为</td>
<td>可以shutdown，reboot等等</td>
<td>业务进程的生命周期</td>
</tr>
<tr>
<td>网络</td>
<td>也是veth peer接到网络命名空间</td>
<td>同</td>
</tr>
<tr>
<td>存储</td>
<td>多种，默认dir后端则是直接用host上的文件夹,/var/lib/lxd/containers/xxxx/rootfs</td>
<td>aufs,devicemapper</td>
</tr>
<tr>
<td>生态</td>
<td>与openstack比较紧密，nova-lxd,nova-libvirtdriver-libvirtlxc</td>
<td>k8s,</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>轻应用，新应用都是微服务化，做docker化改造不算难</li>
<li>传统重应用，已然在虚机/物理机上跑得好好的，如果没有足够的收益，不足以说服去迁移到lxc</li>
<li>现实的问题，由于docker太火，很多应用都已经docker化了</li>
<li>lxc主要的场景，就在于虚拟机和docker的夹缝之中<ol>
<li>需要用到物理机设备的重型应用，比如GPU？虚拟机的虚拟化层需要做适配，docker则对此类重型应用水土不服。</li>
<li>经过测试LXC的IO，网络性能与物理机基本一致，性能比虚拟机要好。</li>
<li>比docker更像虚拟机，比虚拟机更轻量性能更好？</li>
</ol>
</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker偏向于应用，LXC偏向于资源，其产品形态更像是一台虚拟机，所以其有个名字叫系统容器/机器容器。&lt;br&gt;然而，在当前docker大势已成，虚拟机经久不衰的形势下，lxc的优势和劣势都有哪些？&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="LXC" scheme="http://blog.decbug.com/tags/LXC/"/>
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>网络笔记--docker,neutron</title>
    <link href="http://blog.decbug.com/2017/02/10/network_intro/"/>
    <id>http://blog.decbug.com/2017/02/10/network_intro/</id>
    <published>2017-02-09T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.417Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录之前搞容器网络用的基础知识<br><a id="more"></a></p>
<h1 id="ip命令"><a href="#ip命令" class="headerlink" title="ip命令"></a>ip命令</h1><ul>
<li>ip addr</li>
<li>ip route</li>
<li>ip a</li>
<li>ip veth peer</li>
<li>ip link set xxx up</li>
</ul>
<h1 id="brctl"><a href="#brctl" class="headerlink" title="brctl"></a>brctl</h1><p>linux bridge</p>
<ul>
<li>brctl add</li>
<li>brctl addif</li>
<li>brctl show</li>
</ul>
<h1 id="ovs"><a href="#ovs" class="headerlink" title="ovs"></a>ovs</h1><p>open flow</p>
<ul>
<li>ovs-vsctl</li>
<li>dump file</li>
<li>ovs-ofctl</li>
</ul>
<h1 id="neutron"><a href="#neutron" class="headerlink" title="neutron"></a>neutron</h1><ul>
<li>neutron net-CRUD</li>
<li>neutron subnet-CRUD</li>
<li>neutron port-CRUD<br>tap-qbr(linux桥)-brint(ovs桥)</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录之前搞容器网络用的基础知识&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="neutron" scheme="http://blog.decbug.com/tags/neutron/"/>
    
      <category term="ovs" scheme="http://blog.decbug.com/tags/ovs/"/>
    
  </entry>
  
  <entry>
    <title>KVM的几种缓存模式</title>
    <link href="http://blog.decbug.com/2017/01/17/KVM_cache/"/>
    <id>http://blog.decbug.com/2017/01/17/KVM_cache/</id>
    <published>2017-01-16T17:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>现象：</p>
<ol>
<li>虚拟机的IO性能比物理机/容器好？</li>
<li>容器和物理机差不多，这个很好理解，如果没有做IO limit，肯定和物理机相近</li>
<li>用的virsh disk-attach宿主机上的一个/dev/sdxxx，用的是default</li>
<li>顺序读写完爆物理机</li>
<li>随机读写从1K，4K，16K到1M都比物理机强，唯有64M的写比物理机差</li>
</ol>
<p>比较奇怪，需要分析一下</p>
<a id="more"></a>
<h1 id="改cache-mode"><a href="#改cache-mode" class="headerlink" title="改cache mode"></a>改cache mode</h1><blockquote>
<p>writethrough<br>writethrough mode is the default caching mode. With caching set to writethrough mode, the host page cache is enabled, but the disk write cache is disabled for the guest. Consequently, this caching mode ensures data integrity even if the applications and storage stack in the guest do not transfer data to permanent storage properly (either through fsync operations or file system barriers). Because the host page cache is enabled in this mode, the read performance for applications running in the guest is generally better. However, the write performance might be reduced because the disk write cache is disabled.<br>默认模式，认为host page开启，没有用disk cache，会保证数据可靠，写性能会差，读性能会好？</p>
<p>writeback<br>With caching set to writeback mode, both the host page cache and the disk write cache are enabled for the guest. Because of this, the I/O performance for applications running in the guest is good, but the data is not protected in a power failure. As a result, this caching mode is recommended only for temporary data where potential data loss is not a concern.<br>host page和disk cache都开启，性能最好，但在掉电时会有丢数据的风险</p>
<p>none<br>With caching mode set to none, the host page cache is disabled, but the disk write cache is enabled for the guest. In this mode, the write performance in the guest is optimal because write operations bypass the host page cache and go directly to the disk write cache. If the disk write cache is battery-backed, or if the applications or storage stack in the guest transfer data properly (either through fsync operations or file system barriers), then data integrity can be ensured. However, because the host page cache is disabled, the read performance in the guest would not be as good as in the modes where the host page cache is enabled, such as writethrough mode.<br>只开disk cache，不开host page，号称写性能最强，读一般</p>
<p>unsafe<br>Caching mode of unsafe ignores cache transfer operations completely. As its name implies, this caching mode should be used only for temporary data where data loss is not a concern. This mode can be useful for speeding up guest installations, but you should switch to another caching mode in production environments.<br>只写到缓存，不落盘，建议只保存临时数据</p>
</blockquote>
<p>改成none试了下，竟然性能都变差？按理说写性能会提升啊？</p>
<h1 id="host-page-cache对性能的影响"><a href="#host-page-cache对性能的影响" class="headerlink" title="host page cache对性能的影响"></a>host page cache对性能的影响</h1><ul>
<li>64M性能下降是因为cache被打穿？对于大块用direct IO性能更好？即使改成direct IO，那么也是只绕过guest os的page cache啊？此时用none会更好？然而实际上，none的性能不好。</li>
<li>只要有空闲，系统的cache buffer都会很大。物理机是128G内存，所以虚拟机的读写操作都在内存里完成？</li>
<li>小块性能好，因为都在内存里？</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>真的是缓存的原因？大丈夫？</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.slideshare.net/meituan/kvmopt-osforce-27669119" target="_blank" rel="external">美团技术团队 - KVM性能优化</a><br><a href="https://www.ibm.com/support/knowledgecenter/linuxonibm/liaat/liaatbpkvmguestcache.htm" target="_blank" rel="external">Best practice: KVM guest caching modes</a><br><a href="http://www.cnblogs.com/jusonalien/p/4772618.html" target="_blank" rel="external">qemu-kvm磁盘读写的缓冲(cache)的五种模式</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机的IO性能比物理机/容器好？&lt;/li&gt;
&lt;li&gt;容器和物理机差不多，这个很好理解，如果没有做IO limit，肯定和物理机相近&lt;/li&gt;
&lt;li&gt;用的virsh disk-attach宿主机上的一个/dev/sdxxx，用的是default&lt;/li&gt;
&lt;li&gt;顺序读写完爆物理机&lt;/li&gt;
&lt;li&gt;随机读写从1K，4K，16K到1M都比物理机强，唯有64M的写比物理机差&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比较奇怪，需要分析一下&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="KVM" scheme="http://blog.decbug.com/tags/KVM/"/>
    
      <category term="cache" scheme="http://blog.decbug.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>Neutron与容器网络</title>
    <link href="http://blog.decbug.com/2017/01/15/container_neutron/"/>
    <id>http://blog.decbug.com/2017/01/15/container_neutron/</id>
    <published>2017-01-14T17:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>容器用Neutron组网，比Flannel和VPC router强的地方在于</p>
<ul>
<li>多租户，不同租户的容器可以运行在同一个宿主机上。<ol>
<li>Flannel没有租户隔离，</li>
<li>阿里云则是先用租户开虚拟机，利用I层的隔离，同一个虚拟机只能跑一个租户的容器</li>
</ol>
</li>
<li>性能，如果是部署在openstack发放的虚拟机上，则不用在overlay一层</li>
</ul>
<a id="more"></a>
<h1 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a>大概原理</h1><p>记录一下</p>
<ol>
<li>neutron create port</li>
<li>docker network create bridge xxxx， docker run -net=xxxx</li>
<li>管理xxxx的CIDR</li>
<li>bridge veth pair   &lt;—&gt; (port IP MAC) veth pair port的qbr上</li>
<li>dvr add : xxxx的CIDR nexthop 是一个neutron port</li>
</ol>
<p>在这个图上稍作修改<br><img src="http://img.blog.csdn.net/20141208150804139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FueGluZ2hlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="neutron组网"></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器用Neutron组网，比Flannel和VPC router强的地方在于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多租户，不同租户的容器可以运行在同一个宿主机上。&lt;ol&gt;
&lt;li&gt;Flannel没有租户隔离，&lt;/li&gt;
&lt;li&gt;阿里云则是先用租户开虚拟机，利用I层的隔离，同一个虚拟机只能跑一个租户的容器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;性能，如果是部署在openstack发放的虚拟机上，则不用在overlay一层&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="network" scheme="http://blog.decbug.com/tags/network/"/>
    
      <category term="neutron" scheme="http://blog.decbug.com/tags/neutron/"/>
    
      <category term="openstack" scheme="http://blog.decbug.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>conver socks5 to http proxy</title>
    <link href="http://blog.decbug.com/2017/01/10/socks5_http/"/>
    <id>http://blog.decbug.com/2017/01/10/socks5_http/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.421Z</updated>
    
    <content type="html"><![CDATA[<p>go get, but connect to golang.org timeout!!!</p>
<a id="more"></a>
<h1 id="polipo"><a href="#polipo" class="headerlink" title="polipo"></a>polipo</h1><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> install polipo</span><br></pre></td></tr></table></figure>
<h2 id="etc-polipo-config"><a href="#etc-polipo-config" class="headerlink" title="/etc/polipo/config"></a>/etc/polipo/config</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">logSyslog = <span class="value"><span class="keyword">true</span></span></span></span><br><span class="line"><span class="setting">logFile = <span class="value">/var/log/polipo/polipo.log</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="setting">proxyAddress = <span class="value"><span class="string">"10.164.28.139"</span></span></span></span><br><span class="line"><span class="setting">proxyPort = <span class="value"><span class="number">8118</span></span></span></span><br><span class="line"><span class="setting">socksParentProxy = <span class="value"><span class="string">"127.0.0.1:1080"</span></span></span></span><br><span class="line"><span class="setting">socksProxyType = <span class="value">socks5</span></span></span><br><span class="line"><span class="setting">allowedClients = <span class="value">[]</span></span></span><br></pre></td></tr></table></figure>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go get, but connect to golang.org timeout!!!&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="proxy" scheme="http://blog.decbug.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>一次容器网络问题debug</title>
    <link href="http://blog.decbug.com/2017/01/03/container_network_debug/"/>
    <id>http://blog.decbug.com/2017/01/03/container_network_debug/</id>
    <published>2017-01-02T17:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>基于neutron做了一个容器网络方案，需要测试性能，用的iperf，但是在测试过程中，tcp/udp无法抵达跨节点的容器中</p>
<a id="more"></a>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>网络组好之后，跨宿主机的容器相互可以ping通，但是在用iperf测试的时候</p>
<ol>
<li>tcp：client端一直显示带宽为0，server端显示建立连接，但是一直显示收到0字节</li>
<li>udp：client端显示12G的带宽，server端只显示建立连接，但没有其他响应。</li>
</ol>
<p>顺便说一下一直以来对于VxLan的一个疑惑，VxLan是通过udp发送，那么如何保证数据可靠传输呢？是不是udp里封了tcp的包，如果udp丢失了数据</p>
<h1 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h1><ol>
<li>在容器A里起一个python SimpleHTTPServer，在容器B里curl这个server。A容器收到请求，并且响应，但是B容器没有收到响应</li>
<li>猜测是不是安全组的问题？于是neutron secure-group-create 端口从1到65535，ingress egress，tcp udp都加上，再次curl，还是不通</li>
<li>用tcpdump同时在server端和client端抓包，保存起来</li>
<li>在两个宿主机起python server，也curl一次并抓包</li>
<li>用wireshark对比两次的包，发现容器里curl多了一个1518 length的包，于是猜测是不是MTU的问题？因为之前在看flannel的时候，需要在docker启动参数上设置MTU为1450</li>
<li>分别在两个容器都设置mtu：ip netns 容器网络命名空间 ifconfig eth0 mtu 1400</li>
<li>再次curl，容器B收到响应</li>
<li>继续iperf，tcp的可以测通，性能和用neutron的虚拟机相似</li>
<li>但是udp还是不通</li>
<li>继续抓两个容器的docker0，可以收到数据</li>
<li>两个veth，也可以收到</li>
<li>但是在容器的eth0却收不到。按理说是veth pair，一端收到，另一端就肯定能收到。</li>
</ol>
<p>看来还有问题，需要继续定位</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于neutron做了一个容器网络方案，需要测试性能，用的iperf，但是在测试过程中，tcp/udp无法抵达跨节点的容器中&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="network" scheme="http://blog.decbug.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>山寨版sysdig cloud</title>
    <link href="http://blog.decbug.com/2016/12/06/sysdig_knockoff/"/>
    <id>http://blog.decbug.com/2016/12/06/sysdig_knockoff/</id>
    <published>2016-12-05T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.421Z</updated>
    
    <content type="html"><![CDATA[<p>调用链分析有三种模式：</p>
<ol>
<li>白盒，zipkin</li>
<li>灰盒，pinpoint，往JVM里注入</li>
<li>黑盒，优点是难度大，精度一般，优点是不用改代码</li>
</ol>
<p>之前分析的sysdig就算是黑盒,<a href="http://blog.decbug.com/2016/10/12/sysdig/">http://blog.decbug.com/2016/10/12/sysdig/</a>，恰好有需求说想不改代码，由容器云平台提供调用链分析。</p>
<p>参考了几篇论文及业内快讯之后，</p>
<ul>
<li>IBM的<a href="http://www.spark.tc/real-time-application-performance-profiling-using-spark/" target="_blank" rel="external">Real-time Performance Profiling &amp; Analytics for Microservices using Apache </a></li>
<li>MIT的<a href="https://pdos.csail.mit.edu/~athicha/papers/blackboxes:sosp03.pdf" target="_blank" rel="external">Performance Debugging for Distributed Systems of Black Boxes</a></li>
</ul>
<p>花了一周时间在k8s上做出来了，当然，由于缺乏算法支持，目前只做到了点对点的调用topo及http,memcached的时延，后面有空再补齐MySQL等等。</p>
<a id="more"></a>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><ul>
<li>用开源sysdig做采集</li>
<li>参考http_log和memorycache，自己写了个Chisel做过滤分析</li>
<li>过滤后的日志print到std output，然后打到起了syslog的logstash容器</li>
<li>logstack到elastic search</li>
<li>之后写个可视化的web服务，根据用户的查询条件，把对应的topo及时延画出来，就可以辅助诊断性能问题</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调用链分析有三种模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;白盒，zipkin&lt;/li&gt;
&lt;li&gt;灰盒，pinpoint，往JVM里注入&lt;/li&gt;
&lt;li&gt;黑盒，优点是难度大，精度一般，优点是不用改代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前分析的sysdig就算是黑盒,&lt;a href=&quot;http://blog.decbug.com/2016/10/12/sysdig/&quot;&gt;http://blog.decbug.com/2016/10/12/sysdig/&lt;/a&gt;，恰好有需求说想不改代码，由容器云平台提供调用链分析。&lt;/p&gt;
&lt;p&gt;参考了几篇论文及业内快讯之后，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IBM的&lt;a href=&quot;http://www.spark.tc/real-time-application-performance-profiling-using-spark/&quot;&gt;Real-time Performance Profiling &amp;amp; Analytics for Microservices using Apache &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MIT的&lt;a href=&quot;https://pdos.csail.mit.edu/~athicha/papers/blackboxes:sosp03.pdf&quot;&gt;Performance Debugging for Distributed Systems of Black Boxes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;花了一周时间在k8s上做出来了，当然，由于缺乏算法支持，目前只做到了点对点的调用topo及http,memcached的时延，后面有空再补齐MySQL等等。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
      <category term="tracing" scheme="http://blog.decbug.com/tags/tracing/"/>
    
  </entry>
  
  <entry>
    <title>阿里云容器服务分析</title>
    <link href="http://blog.decbug.com/2016/12/05/aliyun_container/"/>
    <id>http://blog.decbug.com/2016/12/05/aliyun_container/</id>
    <published>2016-12-04T17:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>分析一下阿里云容器服务</p>
<a id="more"></a>
<h1 id="计算调度"><a href="#计算调度" class="headerlink" title="计算调度"></a>计算调度</h1><ul>
<li>swarm</li>
<li>用户先买几台虚拟机，之后在虚拟机上安装swarm</li>
<li>利用阿里云已有能力，在I层就实现了租户隔离</li>
<li>用户的集群规模不会很大，swarm的调度也能跟上</li>
<li>疑问：资源利用率？这不算是个PaaS吧<br><img src="http://dockerone.com/uploads/article/20160420/979b0743ac5f99e1467721b4cf6a8393.png" alt=""></li>
</ul>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><ul>
<li>阿里云vswitch, vrouter</li>
<li>利用阿里云已有IaaS的能力，不用overlay over overlay</li>
<li>性能好</li>
<li>其他容器厂商没有I层的能力，果然是大树底下好乘凉<br><img src="http://dockerone.com/uploads/article/20160420/cd9e52ae1faba951eabe808d2a1ffbf3.png" alt=""></li>
</ul>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><ul>
<li>扩展了plugin，可以接入OSS作为卷挂载到宿主机，之后mount到容器</li>
<li>依然是大树下好乘凉</li>
<li>卖容器的同时，还能卖OSS</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>可以接入阿里云的各种服务，如LB，redis，mysql</li>
<li>看来是想构建阿里云全家桶，可以卖出更多产品，很好的思路</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析一下阿里云容器服务&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="container" scheme="http://blog.decbug.com/tags/container/"/>
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>sudoers分析</title>
    <link href="http://blog.decbug.com/2016/12/05/sudoers/"/>
    <id>http://blog.decbug.com/2016/12/05/sudoers/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.421Z</updated>
    
    <content type="html"><![CDATA[<p>对于敏感命令，需要限制其使用范围，防止被攻击提权。至于如何提权，一搜就一大片例子，故不赘述。<br>为了解决此问题，需要找出系统用到了sudo的地方，然后把命令的具体参数都记录下来，写入到sudoers，避免使用其他参数。</p>
<a id="more"></a>
<h1 id="etc-sudoers"><a href="#etc-sudoers" class="headerlink" title="/etc/sudoers"></a>/etc/sudoers</h1><ul>
<li>需要用visudo打开，如果有语法错误，那么在保存时会有warning</li>
<li>行首是”%”的，表示是group，这一个group的全部用户都适用于这个sudo的定义；行首是用户名的，表示是用户。</li>
<li>注意特殊字符需要转义<code>The following characters must be escaped with a backslash (‘\’) when used as part of a word (e.g. a user name or host name): ‘!’, ‘=’, ‘:’, ‘,’, ‘(’, ‘)’, ‘\’.</code></li>
</ul>
<h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><p>以前的做法，看代码，找出全部用到sudo的脚本，代码等等。汇总之后写入到sudoers，耗时费力，大家苦不堪言，却没有想过改变。这次轮到我来干这类事，我觉得是在浪费生命，于是相处了偷懒的办法</p>
<ol>
<li>打开sudo的log，方法：在sudoers加上一行<code>Defaults          logfile=/var/log/sudo.log</code></li>
<li>之后运行我们的系统，一段时间后，基本上全部命令都执行到了，log里保存了全部的sudo记录</li>
<li>分析过滤提取<code>/var/log/sudo.log</code>，就能找出我们系统用到的sudo相关命令</li>
<li>自动汇总，写入到/etc/sudoers</li>
</ol>
<p>以前需要N人天才能做完的是，我花了1天写代码，之后5分钟就搞定。节省了N多人力物力，可以把时间投入到更有技术含量的工作中去。</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于敏感命令，需要限制其使用范围，防止被攻击提权。至于如何提权，一搜就一大片例子，故不赘述。&lt;br&gt;为了解决此问题，需要找出系统用到了sudo的地方，然后把命令的具体参数都记录下来，写入到sudoers，避免使用其他参数。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="sudoers" scheme="http://blog.decbug.com/tags/sudoers/"/>
    
  </entry>
  
  <entry>
    <title>通过libcap抓包</title>
    <link href="http://blog.decbug.com/2016/10/16/libcap/"/>
    <id>http://blog.decbug.com/2016/10/16/libcap/</id>
    <published>2016-10-15T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.417Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/5423628/19422110/910d9144-9441-11e6-87e8-a5919a41d8b1.png" alt="image"></p>
<p>原理</p>
<a id="more"></a>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19422117/a283aa58-9441-11e6-9276-16e9ba0ded25.png" alt="image"></p>
<p>用的是libcap抓的ip及len都不对，于是不用普罗米修斯模式，len对了，但是ip还是不对。继续分析。</p>
<p>把抓到的首部都打出来，和用tcpdump抓到的进行比较，内容一致，那么说明抓包正确，只是我的解析代码不对</p>
<p>由于inet_ntoa是静态buffer，所以第二次和第一次一样，改成inet_ntop就好了，因为不是静态buffer</p>
<p>收获挺大，把ip和tcp首部的每个字节都搞明白了</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/Seiyagoo/archive/2012/04/28/2475618.html" target="_blank" rel="external">http://www.cnblogs.com/Seiyagoo/archive/2012/04/28/2475618.html</a><br><a href="http://www.tcpdump.org/" target="_blank" rel="external">http://www.tcpdump.org/</a><br><a href="http://recursos.aldabaknocking.com/libpcapHakin9LuisMartinGarcia.pdf" target="_blank" rel="external">http://recursos.aldabaknocking.com/libpcapHakin9LuisMartinGarcia.pdf</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5423628/19422110/910d9144-9441-11e6-87e8-a5919a41d8b1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;原理&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="tcpdump" scheme="http://blog.decbug.com/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>调用链技术分析</title>
    <link href="http://blog.decbug.com/2016/10/14/tracing/"/>
    <id>http://blog.decbug.com/2016/10/14/tracing/</id>
    <published>2016-10-13T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371598/083f6f56-91e7-11e6-8964-63f4780885f1.png" alt="分布式调用"></p>
<p>都源于google的dapper，常见的有三种方式</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>概要</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>自己打日志</td>
<td>请求进入时生成ID，每次跨节点调用都带上ID，日志也打上ID</td>
<td>自己实现（这个算不算优点）</td>
<td>麻烦</td>
</tr>
<tr>
<td>用开源库，如zipkin</td>
<td>原理都差不多，都是ID spanID parentID</td>
<td>简单，client和server都有例子</td>
<td>需要集成</td>
</tr>
<tr>
<td>改分布式框架，如鹰眼，京东改dubbo</td>
<td>不用侵入业务代码，在框架里做好埋点和日志</td>
<td>自己实现</td>
<td>稍微麻烦，需要自己改框架</td>
</tr>
<tr>
<td>运行环境注入</td>
<td>例如<a href="https://newrelic.com/" target="_blank" rel="external">newrelic</a>，<a href="https://github.com/naver/pinpoint" target="_blank" rel="external">pinpoint</a>，改JVM运行时bytecode</td>
<td>非侵入</td>
<td>性能损耗比较大</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h1 id="dapper论文"><a href="#dapper论文" class="headerlink" title="dapper论文"></a>dapper论文</h1><p><img src="https://cloud.githubusercontent.com/assets/5423628/19371479/05ebe2b2-91e6-11e6-9a89-9827415d9464.png" alt="image"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371503/288995bc-91e6-11e6-9e68-8b198725a8a8.png" alt="image"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371519/3f05e1e2-91e6-11e6-84cf-77c2f095ff74.png" alt="image"></p>
<h1 id="zipkin"><a href="#zipkin" class="headerlink" title="zipkin"></a>zipkin</h1><p>在公司体验了一下，流程和<a href="https://yq.aliyun.com/articles/60165?spm=5176.100244.teamconlist.33.wxgYuD" target="_blank" rel="external">https://yq.aliyun.com/articles/60165?spm=5176.100244.teamconlist.33.wxgYuD</a><br>差不多</p>
<h1 id="改造分布式框架"><a href="#改造分布式框架" class="headerlink" title="改造分布式框架"></a>改造分布式框架</h1><p>在发远程调用，收到远程调用的时候，框架自身记录下来<br>实现起来想必不容易，但收益很大</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5423628/19371598/083f6f56-91e7-11e6-8964-63f4780885f1.png&quot; alt=&quot;分布式调用&quot;&gt;&lt;/p&gt;
&lt;p&gt;都源于google的dapper，常见的有三种方式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;自己打日志&lt;/td&gt;
&lt;td&gt;请求进入时生成ID，每次跨节点调用都带上ID，日志也打上ID&lt;/td&gt;
&lt;td&gt;自己实现（这个算不算优点）&lt;/td&gt;
&lt;td&gt;麻烦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用开源库，如zipkin&lt;/td&gt;
&lt;td&gt;原理都差不多，都是ID spanID parentID&lt;/td&gt;
&lt;td&gt;简单，client和server都有例子&lt;/td&gt;
&lt;td&gt;需要集成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;改分布式框架，如鹰眼，京东改dubbo&lt;/td&gt;
&lt;td&gt;不用侵入业务代码，在框架里做好埋点和日志&lt;/td&gt;
&lt;td&gt;自己实现&lt;/td&gt;
&lt;td&gt;稍微麻烦，需要自己改框架&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;运行环境注入&lt;/td&gt;
&lt;td&gt;例如&lt;a href=&quot;https://newrelic.com/&quot;&gt;newrelic&lt;/a&gt;，&lt;a href=&quot;https://github.com/naver/pinpoint&quot;&gt;pinpoint&lt;/a&gt;，改JVM运行时bytecode&lt;/td&gt;
&lt;td&gt;非侵入&lt;/td&gt;
&lt;td&gt;性能损耗比较大&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>sysdig源码分析</title>
    <link href="http://blog.decbug.com/2016/10/12/sysdig/"/>
    <id>http://blog.decbug.com/2016/10/12/sysdig/</id>
    <published>2016-10-11T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.421Z</updated>
    
    <content type="html"><![CDATA[<p>之前分析APM的时候，试用了sysdig，觉得sysdig很厉害</p>
<ol>
<li>通过内核抓事件，不用侵入到容器</li>
<li>可以自己写铲子，扩展起来很方便。<br>于是就顺手看下他的实现原理</li>
</ol>
<a id="more"></a>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/draios/sysdig" target="_blank" rel="external">https://github.com/draios/sysdig</a></p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><img src="http://www.plantuml.com/plantuml/svg/NOzB3i8m34JtFOML1MgHk0Ai4E8C1Q7G3gs5vQ8wV4zFa_8JondRyyRvjA3PR4vkhHpO2pzyu4vTbYNNxbPpGpqQje2US866zx1gsI2vd7r1dUvuIDWe6SBkm1At9qcO-fCWHevdH_GA-KJnWTorPG6j49RHN3WABJGZYjNAEsmxmBp8tbT7gbmQp7-jLEJh9nahlHXZq3yPOiZYHQdT0C2DNv-LIwrP6phrNGKRuFcqU080">
<h1 id="chisels的原理"><a href="#chisels的原理" class="headerlink" title="chisels的原理"></a>chisels的原理</h1><p>安装之后会在/usr/share/sysdig/chisels，看下memcachelog这个铲子的代码<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Initialization callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on_init</span><span class="params">()</span></span></span><br><span class="line">    util = &#123;&#125;</span><br><span class="line">    start_time = <span class="built_in">os</span>.time()</span><br><span class="line">    sysdig.set_filter(<span class="string">"(fd.sport=11211 or proc.name=memcached) and evt.is_io=true"</span>)</span><br><span class="line">    sysdig.set_snaplen(<span class="number">4096</span>)</span><br><span class="line">    data = chisel.request_field(<span class="string">"evt.arg[1]"</span>)</span><br><span class="line">    datetime = chisel.request_field(<span class="string">"evt.datetime"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Event callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on_event</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> data = evt.field(data)</span><br><span class="line">  <span class="keyword">local</span> line = split(data, <span class="string">" "</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">string</span>.match(line[<span class="number">1</span>], <span class="string">'^[gs]et'</span>) ~= <span class="keyword">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> method = line[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">local</span> key = line[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">local</span> size = <span class="built_in">tonumber</span>(line[<span class="number">5</span>]) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> key ~= <span class="keyword">nil</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> opt_method ~= <span class="keyword">nil</span> <span class="keyword">and</span> opt_method ~= method <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> opt_method == <span class="string">'set'</span> <span class="keyword">and</span> size &lt; opt_size <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">string</span>.format(<span class="string">"%s method=%s size=%dB key=%s"</span>,</span><br><span class="line">              evt.field(datetime),</span><br><span class="line">              method,</span><br><span class="line">              size,</span><br><span class="line">              key</span><br><span class="line">      ))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>on_init 设置filter，以及需要哪些data field</p>
<p>on_event，获取参数，得到method，是get/set，以及key</p>
<h1 id="sysdig原理"><a href="#sysdig原理" class="headerlink" title="sysdig原理"></a>sysdig原理</h1><p><code>driver/event_table.c</code> 事件都在这里g_event_info</p>
<p><code>driver/ppm_fillers.c</code> g_ppm_events事件的回调</p>
<p><code>userspace/libsinsp/chisel_api.cpp</code> lua_cbacks这个类是，lua调用c代码的接口</p>
<p>疑问：</p>
<ol>
<li>当事件发生，如何通过g_ppm_events里的回调函数再调用到lua里的on_event</li>
<li>event_table里的事件是如何发送到内核的？用到哪个API？是不是和systemtap差不多？</li>
</ol>
<p>晚上回家继续看看</p>
<h2 id="event-table里的事件是如何发送到内核的"><a href="#event-table里的事件是如何发送到内核的" class="headerlink" title="event_table里的事件是如何发送到内核的"></a>event_table里的事件是如何发送到内核的</h2><p>event_table里的事件是如何发送到内核的？用到哪个API？是不是和systemtap差不多？<br>翻了下源码，终于找到了<br>sysdig_init-&gt;get_tracepoint_handler-&gt;g_ppm_fops-&gt;ppm_open-&gt;compat_register-&gt;TRACEPOINT_PROBE_REGISTER-&gt;内核的tracepoint_probe_register</p>
<p>两个参数，一个是tracepoint name,另一个则是回调</p>
<h1 id="slideshare上的流程"><a href="#slideshare上的流程" class="headerlink" title="slideshare上的流程"></a>slideshare上的流程</h1><p><img src="https://cloud.githubusercontent.com/assets/5423628/19371219/091e8342-91e4-11e6-8a53-f2e597860efb.png" alt="syscall"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371250/40b1dd72-91e4-11e6-97c8-29ac829afde8.png" alt="event_collector"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371280/6b0da6be-91e4-11e6-9c9b-77b151f8428c.png" alt="container"></p>
<p><a href="http://www.slideshare.net/SreenivasMakam/container-monitoring-with-sysdig-58790785" target="_blank" rel="external">http://www.slideshare.net/SreenivasMakam/container-monitoring-with-sysdig-58790785</a></p>
<p><a href="http://www.slideshare.net/Sysdig/sysdig-meetup-dec2014" target="_blank" rel="external">http://www.slideshare.net/Sysdig/sysdig-meetup-dec2014</a></p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysdig <span class="operator">-l</span> <span class="comment"># 查看所有field</span></span><br><span class="line">sysdig -L <span class="comment"># 进事件，出事件的参数</span></span><br></pre></td></tr></table></figure>
<p>关注 fd.name, proc.name, fd.cip/sip/port/lip, datetime时间戳, fd.num标识唯一的一次连接, containername/ID, pid, tid</p>
<p>还有个tracer没太搞明白，里边有span等等，有时间再研究下</p>
<h1 id="其他内核trace"><a href="#其他内核trace" class="headerlink" title="其他内核trace"></a>其他内核trace</h1><table>
<thead>
<tr>
<th>时间</th>
<th>名字</th>
<th>主要技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>2000</td>
<td>Linux Trace Toolkit (LTT)</td>
<td></td>
</tr>
<tr>
<td>2005</td>
<td>LInux Trace Toolkit Next Generation (LTTng)</td>
<td></td>
</tr>
<tr>
<td>2008</td>
<td>Tracepoint</td>
<td>后面就用这个比较多？</td>
</tr>
<tr>
<td>xxxx</td>
<td>systemTAP</td>
<td>貌似也是用tracepoint probe</td>
</tr>
<tr>
<td>xxxx</td>
<td>ftrace</td>
<td>也是tracepoint</td>
</tr>
</tbody>
</table>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前分析APM的时候，试用了sysdig，觉得sysdig很厉害&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过内核抓事件，不用侵入到容器&lt;/li&gt;
&lt;li&gt;可以自己写铲子，扩展起来很方便。&lt;br&gt;于是就顺手看下他的实现原理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>APM厂商分析</title>
    <link href="http://blog.decbug.com/2016/10/10/APM/"/>
    <id>http://blog.decbug.com/2016/10/10/APM/</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务大行其道的今天，系统的实例越来越多，出现性能问题时要调试就很困难。于是乎，就出现了许多APM厂商，只需要装一个agent，就能通过监控系统调用，网络传输，性能指标，辅助调试定位性能问题。</p>
<p>在公司分析了很多，也抓包了，详细内容带不出来。就简单记个笔记，供以后回忆</p>
<a id="more"></a>
<h1 id="sysdig"><a href="#sysdig" class="headerlink" title="sysdig"></a>sysdig</h1><p>分为<a href="https://github.com/draios/sysdig" target="_blank" rel="external">开源版sysdig.org</a>和<a href="https://sysdig.com/" target="_blank" rel="external">商业版sysdig cloud</a></p>
<h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>原理：抓内核级别的调用，比如read，write，网络也是read，write，只不过描述符不一样，然后形成事件，记录下来<br>还有个强大的功能Chisel，很好玩，可以自己扩展功能，用lua写<br><a href="https://github.com/draios/sysdig/wiki/Writing-a-Sysdig-Chisel,-a-Tutorial" target="_blank" rel="external">Writing a Sysdig Chisel, a Tutorial</a></p>
<h2 id="sysdig-cloud"><a href="#sysdig-cloud" class="headerlink" title="sysdig cloud"></a>sysdig cloud</h2><p>装一个agent，用的是开源的sysdig采集数据，然后上报到sysdig cloud的服务器。</p>
<ul>
<li>可以展示topo，调用耗时等等</li>
<li>分析http，可以精确到url</li>
<li>通过分析开源代码，分析出具体的调用，原理应该和chisel中的memcache差不多</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>dynatrace &amp; apptrace<br>都差不多</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微服务大行其道的今天，系统的实例越来越多，出现性能问题时要调试就很困难。于是乎，就出现了许多APM厂商，只需要装一个agent，就能通过监控系统调用，网络传输，性能指标，辅助调试定位性能问题。&lt;/p&gt;
&lt;p&gt;在公司分析了很多，也抓包了，详细内容带不出来。就简单记个笔记，供以后回忆&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>CloudInsightAgent源码分析</title>
    <link href="http://blog.decbug.com/2016/10/10/cloudinght_agent_src/"/>
    <id>http://blog.decbug.com/2016/10/10/cloudinght_agent_src/</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>之前模仿sysdig做了个容器性能监控平台，<a href="http://blog.decbug.com/2016/12/06/sysdig_knockoff/">链接在此</a>，虽然有一些基础的功能，但是还不完善，</p>
<p>恰好看到cloud insight开源了他的agent，看过之后，和我的思路差不多，就简单记录一下，避免遗忘。</p>
<a id="more"></a>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/cloudinsight/cloudinsight-agent" target="_blank" rel="external">https://github.com/cloudinsight/cloudinsight-agent</a></p>
<p>据说之前是python，后来切换到go</p>
<h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── agent</span><br><span class="line">├── collector</span><br><span class="line">│   ├── conf.d          <span class="comment"># plugins的配置文件，比如MySQL的连接串</span></span><br><span class="line">│   └── plugins         <span class="comment"># plugin的代码，有docker，MySQL等</span></span><br><span class="line">├── common              <span class="comment"># 公共包</span></span><br><span class="line">├── forwarder           <span class="comment"># 发到cloud insight服务器</span></span><br><span class="line">├── statsd</span><br><span class="line">└── vendor              <span class="comment"># 三方包</span></span><br></pre></td></tr></table></figure>
<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>init的时候会加载cloudinsight-agent/collector/plugins的插件</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------+</span><br><span class="line">|<span class="string"> main                                     </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">      +-------------------+               </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">config.NewConfig   </span>|<span class="string">               </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">                   </span>|<span class="string">               </span>|</span><br><span class="line">|<span class="string">      +-------------------+               </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">      +-------------------+               </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">startAgent         </span>|<span class="string">               </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">                   </span>|<span class="string">               </span>|</span><br><span class="line">|<span class="string">      +-------------------+               </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">      +-------------------+               </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">startForwarder     </span>|<span class="string">               </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">                   </span>|<span class="string">               </span>|</span><br><span class="line">|<span class="string">      +-------------------+               </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">      +-------------------+               </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">startStatsd        </span>|<span class="string">               </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">                   </span>|<span class="string">               </span>|</span><br><span class="line">|<span class="string">      +-------------------+               </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">|<span class="string">                                          </span>|</span><br><span class="line">+------------------------------------------+</span><br></pre></td></tr></table></figure>
<h1 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h1><p>collector</p>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><h2 id="以docker为例"><a href="#以docker为例" class="headerlink" title="以docker为例"></a>以docker为例</h2><p>Check接口，调用docker daemon的rest api采集</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前模仿sysdig做了个容器性能监控平台，&lt;a href=&quot;http://blog.decbug.com/2016/12/06/sysdig_knockoff/&quot;&gt;链接在此&lt;/a&gt;，虽然有一些基础的功能，但是还不完善，&lt;/p&gt;
&lt;p&gt;恰好看到cloud insight开源了他的agent，看过之后，和我的思路差不多，就简单记录一下，避免遗忘。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
      <category term="monitoring" scheme="http://blog.decbug.com/tags/monitoring/"/>
    
  </entry>
  
  <entry>
    <title>容器分布式存储之Flocker</title>
    <link href="http://blog.decbug.com/2016/10/10/Flocker/"/>
    <id>http://blog.decbug.com/2016/10/10/Flocker/</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>容器的分布式存储都差不多，都是docker daemon-&gt;plugin-&gt;agent-&gt;control，话说cinder也差不多。<br>正好看到了flocker，简单了解一下架构，记录下来加深印象</p>
<a id="more"></a>
<h1 id="flocker"><a href="#flocker" class="headerlink" title="flocker"></a>flocker</h1><p><img src="https://uploads.disquscdn.com/images/b891c982b375e67d8f6e22030c0404e86e3ea54c2f086be24e54dbd921d62e97.png" alt=""></p>
<h1 id="手绘架构图"><a href="#手绘架构图" class="headerlink" title="手绘架构图"></a>手绘架构图</h1><p><img src="https://uploads.disquscdn.com/images/edf315d6c61c5b6ef839fbd8513ebb7969f91d36d87984062f9a779601ba0e10.jpg" alt=""></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器的分布式存储都差不多，都是docker daemon-&amp;gt;plugin-&amp;gt;agent-&amp;gt;control，话说cinder也差不多。&lt;br&gt;正好看到了flocker，简单了解一下架构，记录下来加深印象&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="distributed storage" scheme="http://blog.decbug.com/tags/distributed-storage/"/>
    
  </entry>
  
  <entry>
    <title>VxLan原理</title>
    <link href="http://blog.decbug.com/2016/10/09/VxLan/"/>
    <id>http://blog.decbug.com/2016/10/09/VxLan/</id>
    <published>2016-10-08T16:00:00.000Z</published>
    <updated>2017-04-01T14:11:35.413Z</updated>
    
    <content type="html"><![CDATA[<p>VxLan，网络虚拟化，应用很广泛</p>
<p>简单记录一下原理</p>
<a id="more"></a>
<p><img src="http://www.aboutyun.com/data/attachment/forum/201501/12/200932g95t3x5zlllv0cn3.jpg" alt="Frame Format"></p>
<p><img src="http://www.aboutyun.com/data/attachment/forum/201501/12/201142n2mmll72er7pldlp.jpg" alt=""></p>
<ol>
<li>VM1发送IP数据包到VM2，即192.168.0.100 到 192.168.0.101；</li>
<li>VTEP1查找自己的VXLAN表知道要发给VTEP2，然后依次封装以下数据包头；<ul>
<li>VXLAN包头</li>
<li>标准UDP包头，校验和checksum为0x0000；</li>
<li>标准IP包头，目标地址为VTEP2的IP地址，协议号设为0x11表面为UDP包。</li>
<li>标准MAC数据包，目标地址为下一跳设备的MAC地址00:10:11:FE:D8:D2，可路由到目标隧道端VTEP2。</li>
</ul>
</li>
<li>VTEP2接收数据包，根据UDP的destination端口找到VXLAN数据包。接着查找所有所在VXLAN的VNI为864的端口组，找到VM2的</li>
<li>VM2接收并处理数据包，拿到Payload数据。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.aboutyun.com/thread-11189-1-1.html" target="_blank" rel="external">http://www.aboutyun.com/thread-11189-1-1.html</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VxLan，网络虚拟化，应用很广泛&lt;/p&gt;
&lt;p&gt;简单记录一下原理&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="VxLan" scheme="http://blog.decbug.com/tags/VxLan/"/>
    
  </entry>
  
</feed>
