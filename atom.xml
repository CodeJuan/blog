<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Continuous Learning</title>
  <subtitle>浮云一别后，流水十年间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.decbug.com/"/>
  <updated>2017-02-24T14:20:19.062Z</updated>
  <id>http://blog.decbug.com/</id>
  
  <author>
    <name>CodeJuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cloud-init</title>
    <link href="http://blog.decbug.com/2017/02/24/cloud-init/"/>
    <id>http://blog.decbug.com/2017/02/24/cloud-init/</id>
    <published>2017-02-23T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.062Z</updated>
    
    <content type="html"><![CDATA[<p>刚创出来的虚拟机，要如何设置初始密码？如何添加环境变量？如何进行一系列的预置操作？<br>答案就是cloud-init</p>
<a id="more"></a>
<p>对于open stack来说，cloud-init可以通过两种方式获取数据</p>
<ol>
<li>config drive</li>
<li>通过meta-data服务获取</li>
</ol>
<h1 id="config-drive"><a href="#config-drive" class="headerlink" title="config drive"></a>config drive</h1><p>大概原理及流程</p>
<ol>
<li>生成相关的meta-data.json, user-data</li>
<li>制作iso9xxx格式的iso</li>
<li>挂载到/dev/vdb</li>
<li>cloud-init配置datasource为config drive</li>
<li>cloud-init读取，进行配置</li>
</ol>
<h1 id="meta-data"><a href="#meta-data" class="headerlink" title="meta-data"></a>meta-data</h1><ol>
<li>nova有个meta-data服务</li>
<li>创虚拟机的时候，配置一条路由169.254.169.254</li>
<li>cloud-init配置datasource为openstack</li>
<li>从<a href="http://169.254.169.254/openstack获取meta-data.json" target="_blank" rel="external">http://169.254.169.254/openstack获取meta-data.json</a></li>
<li>进行配置</li>
</ol>
<h1 id="user-data"><a href="#user-data" class="headerlink" title="user-data"></a>user-data</h1><p>nova boot –user-data config.txt</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#cloud-config</span></span><br><span class="line"><span class="label">chpasswd:</span></span><br><span class="line">  list: |</span><br><span class="line">    root:root</span><br><span class="line">    abc:password1</span><br><span class="line"><span class="label">pwauth:</span> True</span><br><span class="line"><span class="label">sshpasswd:</span> yes</span><br><span class="line"></span><br><span class="line"><span class="label">writefiles:</span></span><br><span class="line">  PermitRoot: yes</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://help.ubuntu.com/community/CloudInit" target="_blank" rel="external">https://help.ubuntu.com/community/CloudInit</a><br><a href="http://www.ibm.com/developerworks/cn/cloud/library/1509_liukg_openstackmeta/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/cloud/library/1509_liukg_openstackmeta/index.html</a><br><a href="http://www.chenshake.com/openstack-mirror-and-password/" target="_blank" rel="external">http://www.chenshake.com/openstack-mirror-and-password/</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚创出来的虚拟机，要如何设置初始密码？如何添加环境变量？如何进行一系列的预置操作？&lt;br&gt;答案就是cloud-init&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="openstack" scheme="http://blog.decbug.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>LXC,docker</title>
    <link href="http://blog.decbug.com/2017/02/11/lxc_docker/"/>
    <id>http://blog.decbug.com/2017/02/11/lxc_docker/</id>
    <published>2017-02-10T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.066Z</updated>
    
    <content type="html"><![CDATA[<p>docker偏向于应用，LXC偏向于资源，其产品形态更像是一台虚拟机<br><a id="more"></a></p>
<h1 id="LXC-vs-VM"><a href="#LXC-vs-VM" class="headerlink" title="LXC vs. VM"></a>LXC vs. VM</h1><table>
<thead>
<tr>
<th>对比</th>
<th>LXC</th>
<th>VM</th>
</tr>
</thead>
<tbody>
<tr>
<td>hyper层</td>
<td>用namespace,cgroup,无</td>
<td>有，KVM/XEN</td>
</tr>
<tr>
<td>内核</td>
<td>共用host</td>
<td>有guest</td>
</tr>
<tr>
<td>启动</td>
<td>秒</td>
<td>分</td>
</tr>
</tbody>
</table>
<p>可以说，docker的优点，LXC都有，然而其形态却更像虚拟机</p>
<h1 id="LXC-vs-docker"><a href="#LXC-vs-docker" class="headerlink" title="LXC vs. docker"></a>LXC vs. docker</h1><table>
<thead>
<tr>
<th>对比</th>
<th>LXC</th>
<th>docker</th>
</tr>
</thead>
<tbody>
<tr>
<td>init进程</td>
<td>有systemd作为init进程</td>
<td>entrypoint或cmd里的进程，其实就是业务进程，如果业务进程挂了，容器也跟着消失</td>
</tr>
<tr>
<td>行为</td>
<td>可以shutdown，reboot等等</td>
<td>业务进程的生命周期</td>
</tr>
<tr>
<td>网络</td>
<td>也是veth peer接到网络命名空间</td>
<td>同</td>
</tr>
<tr>
<td>存储</td>
<td>多种，默认dir后端则是直接用host上的文件夹,/var/lib/lxd/containers/xxxx/rootfs</td>
<td>aufs,devicemapper</td>
</tr>
<tr>
<td>生态</td>
<td>与openstack比较紧密，nova-lxd,nova-libvirtdriver-libvirtlxc</td>
<td>k8s,</td>
</tr>
</tbody>
</table>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker偏向于应用，LXC偏向于资源，其产品形态更像是一台虚拟机&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="LXC" scheme="http://blog.decbug.com/tags/LXC/"/>
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>lxd,lxc,nova-lxd</title>
    <link href="http://blog.decbug.com/2017/02/11/nova-lxd-lxc/"/>
    <id>http://blog.decbug.com/2017/02/11/nova-lxd-lxc/</id>
    <published>2017-02-10T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.066Z</updated>
    
    <content type="html"><![CDATA[<p>分析一下lxc, lxd, nova-lxd的关系以及源码</p>
<ul>
<li><a href="https://github.com/openstack/nova-lxd" target="_blank" rel="external">nova-lxd</a>,An OpenStack Compute driver for LXD</li>
<li><a href="https://github.com/lxc/lxd" target="_blank" rel="external">lxd</a>，lxd daemon和lxd client</li>
<li><a href="https://github.com/lxc/lxc" target="_blank" rel="external">lxc</a>，liblxc和lxc-tools</li>
</ul>
<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">                              +---------------+</span><br><span class="line">+----------+                  |               |</span><br><span class="line">| lxc      |                  |   nova-lxd    |</span><br><span class="line">| lxd-client+---+      +------+               |</span><br><span class="line">+----------+    |      |      |               |</span><br><span class="line">                |      |      +---------------+</span><br><span class="line">                |      |</span><br><span class="line">                |      |</span><br><span class="line">             +--v------v---------+</span><br><span class="line">             |     lxd           |</span><br><span class="line">             |                   |</span><br><span class="line">             |Daemon based on    |</span><br><span class="line">             |liblxc offering    |</span><br><span class="line">             |a REST API         |                  +-------------------------+</span><br><span class="line">             |to manage containers                  |                         |</span><br><span class="line">             +--------+----------+                  |   lxc/lxc               |</span><br><span class="line">                      |                             |   tools to              |</span><br><span class="line">                      |                             |   manage containers     |</span><br><span class="line">                      |                             |                         |</span><br><span class="line">             +--------v----------+                  |                         |</span><br><span class="line">             |                   |                  |                         |</span><br><span class="line">             |      go-lxc./v2   |                  +--------+----------------+</span><br><span class="line">             |                   |                           |</span><br><span class="line">             |                   |                           |</span><br><span class="line">             |                   |                           |</span><br><span class="line">             +----------+--------+                           |</span><br><span class="line">                        |                                    |</span><br><span class="line">                        |                                    |</span><br><span class="line">                        |                                    |</span><br><span class="line">                        |                                    |</span><br><span class="line">              +---------v------------------------------------v---------+</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                    liblxc.so                           |</span><br><span class="line">              |                                                        |</span><br><span class="line">              +-------------------------+------------------------------+</span><br><span class="line">                                        |</span><br><span class="line">                                        |</span><br><span class="line">                                        |</span><br><span class="line">              +-------------------------v------------------------------+</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                kernel                                  |</span><br><span class="line">              |                namespace, cgroups                      |</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                                                        |</span><br><span class="line">              |                                                        |</span><br><span class="line">              +--------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="lxd分析"><a href="#lxd分析" class="headerlink" title="lxd分析"></a>lxd分析</h1><p>包含两部分</p>
<ul>
<li>lxd, 类似docker daemon，对外提供restful api</li>
<li>lxc, lxd daemon的客户端</li>
</ul>
<p>lxd daemon通过<code>go lxc v2</code>来调用<code>liblxc.so</code>，其中用到了cgo以及lxc的头文件，所以要先编译liblxc</p>
<h1 id="lxc-tools"><a href="#lxc-tools" class="headerlink" title="lxc-tools"></a>lxc-tools</h1><p><a href="(https://github.com/lxc/lxc/tree/master/src/lxc/tools">lxc-tools</a>)只是<a href="https://github.com/lxc/lxc" target="_blank" rel="external">lxc/lxc</a>的一部分，提供可执行文件用于管理lxc容器。<br>lxc/lxc最重要的部分还是liblxc.so</p>
<h1 id="nova-lxd"><a href="#nova-lxd" class="headerlink" title="nova-lxd"></a>nova-lxd</h1><p>nova-compute的一个driver，类似以前看过的nova-docker</p>
<ul>
<li>相比docker，lxc的行为上更像虚拟机，所以更适合用来和openstack一起玩<a href="http://blog.decbug.com/2017/02/11/lxc_docker/">http://blog.decbug.com/2017/02/11/lxc_docker/</a></li>
<li>北向: 提供spawn, plug-network等接口给nova-compute</li>
<li>南向: 调用lxd daemon管理容器</li>
</ul>
<h2 id="基本功能及流程"><a href="#基本功能及流程" class="headerlink" title="基本功能及流程"></a>基本功能及流程</h2><h3 id="创容器"><a href="#创容器" class="headerlink" title="创容器"></a>创容器</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check to see if LXD already has a copy of the image. If not,</span></span><br><span class="line"><span class="comment"># fetch it.</span></span><br><span class="line">_sync_glance_image_to_lxd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plug in the network</span></span><br><span class="line">plug_vifs(instance, network_info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the profile(including devices, flavor, )</span></span><br><span class="line">container = self.client.containers.create(</span><br><span class="line">                container_config, wait=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># start</span></span><br><span class="line">container.start(wait=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">image = IMAGE_API.get(context, image_ref)</span><br><span class="line">IMAGE_API.download(context, image_ref, dest_path=image_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate metadata.yaml</span></span><br><span class="line">            metadata = &#123;</span><br><span class="line">                <span class="string">'architecture'</span>: image.get(</span><br><span class="line">                    <span class="string">'hw_architecture'</span>, obj_fields.Architecture.from_host()),</span><br><span class="line">                <span class="string">'creation_date'</span>: int(os.stat(image_file).st_ctime)&#125;</span><br><span class="line">            metadata_yaml = json.dumps(</span><br><span class="line">                metadata, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>,</span><br><span class="line">                separators=(<span class="string">','</span>, <span class="string">': '</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment"># add metadata.yaml to tar.gz</span></span><br><span class="line">            tarball = tarfile.open(manifest_file, <span class="string">"w:gz"</span>)</span><br><span class="line">            tarinfo = tarfile.TarInfo(name=<span class="string">'metadata.yaml'</span>)</span><br><span class="line">            tarinfo.size = len(metadata_yaml)</span><br><span class="line">            tarball.addfile(tarinfo, io.BytesIO(metadata_yaml))</span><br><span class="line">            tarball.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># upload tar.gz to local lxd image registry</span></span><br><span class="line">image = client.images.create(</span><br><span class="line">                        image.read(), metadata=manifest.read(),</span><br><span class="line">                        wait=<span class="keyword">True</span>)</span><br><span class="line">            image.add_alias(image_ref, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p><a href="https://github.com/openstack/nova-lxd/blob/master/nova/virt/lxd/vif.py" target="_blank" rel="external">https://github.com/openstack/nova-lxd/blob/master/nova/virt/lxd/vif.py</a></p>
<ul>
<li>plug</li>
<li>unplug</li>
<li>brctl创建linux桥，以及addif</li>
<li>ovs-vsctl创建ovs桥，以及add port(pvo pvi)</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析一下lxc, lxd, nova-lxd的关系以及源码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/openstack/nova-lxd&quot;&gt;nova-lxd&lt;/a&gt;,An OpenStack Compute driver for LXD&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lxc/lxd&quot;&gt;lxd&lt;/a&gt;，lxd daemon和lxd client&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lxc/lxc&quot;&gt;lxc&lt;/a&gt;，liblxc和lxc-tools&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;关系&quot;&gt;&lt;a href=&quot;#关系&quot; class=&quot;headerlink&quot; title=&quot;关系&quot;&gt;&lt;/a&gt;关系&lt;/h1&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;                              +---------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------+                  |               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| lxc      |                  |   nova-lxd    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| lxd-client+---+      +------+               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------+    |      |      |               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                |      |      +---------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                |      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                |      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             +--v------v---------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |     lxd           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                   |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |Daemon based on    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |liblxc offering    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |a REST API         |                  +-------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |to manage containers                  |                         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             +--------+----------+                  |   lxc/lxc               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      |                             |   tools to              |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      |                             |   manage containers     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      |                             |                         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             +--------v----------+                  |                         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                   |                  |                         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |      go-lxc./v2   |                  +--------+----------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                   |                           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                   |                           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                   |                           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             +----------+--------+                           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        |                                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        |                                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        |                                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        |                                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              +---------v------------------------------------v---------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                    liblxc.so                           |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              +-------------------------+------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              +-------------------------v------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                kernel                                  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                namespace, cgroups                      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              |                                                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              +--------------------------------------------------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="container" scheme="http://blog.decbug.com/tags/container/"/>
    
      <category term="lxc" scheme="http://blog.decbug.com/tags/lxc/"/>
    
      <category term="openstack" scheme="http://blog.decbug.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>网络笔记--docker,neutron</title>
    <link href="http://blog.decbug.com/2017/02/10/network_intro/"/>
    <id>http://blog.decbug.com/2017/02/10/network_intro/</id>
    <published>2017-02-09T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.066Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录之前搞容器网络用的基础知识<br><a id="more"></a></p>
<h1 id="ip命令"><a href="#ip命令" class="headerlink" title="ip命令"></a>ip命令</h1><ul>
<li>ip addr</li>
<li>ip route</li>
<li>ip a</li>
<li>ip veth peer</li>
<li>ip link set xxx up</li>
</ul>
<h1 id="brctl"><a href="#brctl" class="headerlink" title="brctl"></a>brctl</h1><p>linux bridge</p>
<ul>
<li>brctl add</li>
<li>brctl addif</li>
<li>brctl show</li>
</ul>
<h1 id="ovs"><a href="#ovs" class="headerlink" title="ovs"></a>ovs</h1><p>open flow</p>
<ul>
<li>ovs-vsctl</li>
<li>dump file</li>
<li>ovs-ofctl</li>
</ul>
<h1 id="neutron"><a href="#neutron" class="headerlink" title="neutron"></a>neutron</h1><ul>
<li>neutron net-CRUD</li>
<li>neutron subnet-CRUD</li>
<li>neutron port-CRUD<br>tap-qbr(linux桥)-brint(ovs桥)</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录之前搞容器网络用的基础知识&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="neutron" scheme="http://blog.decbug.com/tags/neutron/"/>
    
      <category term="ovs" scheme="http://blog.decbug.com/tags/ovs/"/>
    
  </entry>
  
  <entry>
    <title>KVM的几种缓存模式</title>
    <link href="http://blog.decbug.com/2017/01/17/KVM_cache/"/>
    <id>http://blog.decbug.com/2017/01/17/KVM_cache/</id>
    <published>2017-01-16T17:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.062Z</updated>
    
    <content type="html"><![CDATA[<p>现象：</p>
<ol>
<li>虚拟机的IO性能比物理机/容器好？</li>
<li>容器和物理机差不多，这个很好理解，如果没有做IO limit，肯定和物理机相近</li>
<li>用的virsh disk-attach宿主机上的一个/dev/sdxxx，用的是default</li>
<li>顺序读写完爆物理机</li>
<li>随机读写从1K，4K，16K到1M都比物理机强，唯有64M的写比物理机差</li>
</ol>
<p>比较奇怪，需要分析一下</p>
<a id="more"></a>
<h1 id="改cache-mode"><a href="#改cache-mode" class="headerlink" title="改cache mode"></a>改cache mode</h1><blockquote>
<p>writethrough<br>writethrough mode is the default caching mode. With caching set to writethrough mode, the host page cache is enabled, but the disk write cache is disabled for the guest. Consequently, this caching mode ensures data integrity even if the applications and storage stack in the guest do not transfer data to permanent storage properly (either through fsync operations or file system barriers). Because the host page cache is enabled in this mode, the read performance for applications running in the guest is generally better. However, the write performance might be reduced because the disk write cache is disabled.<br>默认模式，认为host page开启，没有用disk cache，会保证数据可靠，写性能会差，读性能会好？</p>
<p>writeback<br>With caching set to writeback mode, both the host page cache and the disk write cache are enabled for the guest. Because of this, the I/O performance for applications running in the guest is good, but the data is not protected in a power failure. As a result, this caching mode is recommended only for temporary data where potential data loss is not a concern.<br>host page和disk cache都开启，性能最好，但在掉电时会有丢数据的风险</p>
<p>none<br>With caching mode set to none, the host page cache is disabled, but the disk write cache is enabled for the guest. In this mode, the write performance in the guest is optimal because write operations bypass the host page cache and go directly to the disk write cache. If the disk write cache is battery-backed, or if the applications or storage stack in the guest transfer data properly (either through fsync operations or file system barriers), then data integrity can be ensured. However, because the host page cache is disabled, the read performance in the guest would not be as good as in the modes where the host page cache is enabled, such as writethrough mode.<br>只开disk cache，不开host page，号称写性能最强，读一般</p>
<p>unsafe<br>Caching mode of unsafe ignores cache transfer operations completely. As its name implies, this caching mode should be used only for temporary data where data loss is not a concern. This mode can be useful for speeding up guest installations, but you should switch to another caching mode in production environments.<br>只写到缓存，不落盘，建议只保存临时数据</p>
</blockquote>
<p>改成none试了下，竟然性能都变差？按理说写性能会提升啊？</p>
<h1 id="host-page-cache对性能的影响"><a href="#host-page-cache对性能的影响" class="headerlink" title="host page cache对性能的影响"></a>host page cache对性能的影响</h1><ul>
<li>64M性能下降是因为cache被打穿？对于大块用direct IO性能更好？即使改成direct IO，那么也是只绕过guest os的page cache啊？此时用none会更好？然而实际上，none的性能不好。</li>
<li>只要有空闲，系统的cache buffer都会很大。物理机是128G内存，所以虚拟机的读写操作都在内存里完成？</li>
<li>小块性能好，因为都在内存里？</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>真的是缓存的原因？大丈夫？</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.slideshare.net/meituan/kvmopt-osforce-27669119" target="_blank" rel="external">美团技术团队 - KVM性能优化</a><br><a href="https://www.ibm.com/support/knowledgecenter/linuxonibm/liaat/liaatbpkvmguestcache.htm" target="_blank" rel="external">Best practice: KVM guest caching modes</a><br><a href="http://www.cnblogs.com/jusonalien/p/4772618.html" target="_blank" rel="external">qemu-kvm磁盘读写的缓冲(cache)的五种模式</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机的IO性能比物理机/容器好？&lt;/li&gt;
&lt;li&gt;容器和物理机差不多，这个很好理解，如果没有做IO limit，肯定和物理机相近&lt;/li&gt;
&lt;li&gt;用的virsh disk-attach宿主机上的一个/dev/sdxxx，用的是default&lt;/li&gt;
&lt;li&gt;顺序读写完爆物理机&lt;/li&gt;
&lt;li&gt;随机读写从1K，4K，16K到1M都比物理机强，唯有64M的写比物理机差&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比较奇怪，需要分析一下&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="KVM" scheme="http://blog.decbug.com/tags/KVM/"/>
    
      <category term="cache" scheme="http://blog.decbug.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>Neutron与容器网络</title>
    <link href="http://blog.decbug.com/2017/01/15/container_neutron/"/>
    <id>http://blog.decbug.com/2017/01/15/container_neutron/</id>
    <published>2017-01-14T17:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.062Z</updated>
    
    <content type="html"><![CDATA[<p>容器用Neutron组网，比Flannel和VPC router强的地方在于</p>
<ul>
<li>多租户，不同租户的容器可以运行在同一个宿主机上。<ol>
<li>Flannel没有租户隔离，</li>
<li>阿里云则是先用租户开虚拟机，利用I层的隔离，同一个虚拟机只能跑一个租户的容器</li>
</ol>
</li>
<li>性能，如果是部署在openstack发放的虚拟机上，则不用在overlay一层</li>
</ul>
<a id="more"></a>
<h1 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a>大概原理</h1><p>记录一下</p>
<ol>
<li>neutron create port</li>
<li>docker network create bridge xxxx， docker run -net=xxxx</li>
<li>管理xxxx的CIDR</li>
<li>bridge veth pair   &lt;—&gt; (port IP MAC) veth pair port的qbr上</li>
<li>dvr add : xxxx的CIDR nexthop 是一个neutron port</li>
</ol>
<p>在这个图上稍作修改<br><img src="http://img.blog.csdn.net/20141208150804139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FueGluZ2hlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="neutron组网"></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器用Neutron组网，比Flannel和VPC router强的地方在于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多租户，不同租户的容器可以运行在同一个宿主机上。&lt;ol&gt;
&lt;li&gt;Flannel没有租户隔离，&lt;/li&gt;
&lt;li&gt;阿里云则是先用租户开虚拟机，利用I层的隔离，同一个虚拟机只能跑一个租户的容器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;性能，如果是部署在openstack发放的虚拟机上，则不用在overlay一层&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="network" scheme="http://blog.decbug.com/tags/network/"/>
    
      <category term="neutron" scheme="http://blog.decbug.com/tags/neutron/"/>
    
      <category term="openstack" scheme="http://blog.decbug.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>conver socks5 to http proxy</title>
    <link href="http://blog.decbug.com/2017/01/10/socks5_http/"/>
    <id>http://blog.decbug.com/2017/01/10/socks5_http/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.066Z</updated>
    
    <content type="html"><![CDATA[<p>go get, but connect to golang.org timeout!!!</p>
<a id="more"></a>
<h1 id="polipo"><a href="#polipo" class="headerlink" title="polipo"></a>polipo</h1><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> install polipo</span><br></pre></td></tr></table></figure>
<h2 id="etc-polipo-config"><a href="#etc-polipo-config" class="headerlink" title="/etc/polipo/config"></a>/etc/polipo/config</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">logSyslog = <span class="value"><span class="keyword">true</span></span></span></span><br><span class="line"><span class="setting">logFile = <span class="value">/var/log/polipo/polipo.log</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="setting">proxyAddress = <span class="value"><span class="string">"10.164.28.139"</span></span></span></span><br><span class="line"><span class="setting">proxyPort = <span class="value"><span class="number">8118</span></span></span></span><br><span class="line"><span class="setting">socksParentProxy = <span class="value"><span class="string">"127.0.0.1:1080"</span></span></span></span><br><span class="line"><span class="setting">socksProxyType = <span class="value">socks5</span></span></span><br><span class="line"><span class="setting">allowedClients = <span class="value">[]</span></span></span><br></pre></td></tr></table></figure>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go get, but connect to golang.org timeout!!!&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="proxy" scheme="http://blog.decbug.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>一次容器网络问题debug</title>
    <link href="http://blog.decbug.com/2017/01/03/container_network_debug/"/>
    <id>http://blog.decbug.com/2017/01/03/container_network_debug/</id>
    <published>2017-01-02T17:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.062Z</updated>
    
    <content type="html"><![CDATA[<p>基于neutron做了一个容器网络方案，需要测试性能，用的iperf，但是在测试过程中，tcp/udp无法抵达跨节点的容器中</p>
<a id="more"></a>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>网络组好之后，跨宿主机的容器相互可以ping通，但是在用iperf测试的时候</p>
<ol>
<li>tcp：client端一直显示带宽为0，server端显示建立连接，但是一直显示收到0字节</li>
<li>udp：client端显示12G的带宽，server端只显示建立连接，但没有其他响应。</li>
</ol>
<p>顺便说一下一直以来对于VxLan的一个疑惑，VxLan是通过udp发送，那么如何保证数据可靠传输呢？是不是udp里封了tcp的包，如果udp丢失了数据</p>
<h1 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h1><ol>
<li>在容器A里起一个python SimpleHTTPServer，在容器B里curl这个server。A容器收到请求，并且响应，但是B容器没有收到响应</li>
<li>猜测是不是安全组的问题？于是neutron secure-group-create 端口从1到65535，ingress egress，tcp udp都加上，再次curl，还是不通</li>
<li>用tcpdump同时在server端和client端抓包，保存起来</li>
<li>在两个宿主机起python server，也curl一次并抓包</li>
<li>用wireshark对比两次的包，发现容器里curl多了一个1518 length的包，于是猜测是不是MTU的问题？因为之前在看flannel的时候，需要在docker启动参数上设置MTU为1450</li>
<li>分别在两个容器都设置mtu：ip netns 容器网络命名空间 ifconfig eth0 mtu 1400</li>
<li>再次curl，容器B收到响应</li>
<li>继续iperf，tcp的可以测通，性能和用neutron的虚拟机相似</li>
<li>但是udp还是不通</li>
<li>继续抓两个容器的docker0，可以收到数据</li>
<li>两个veth，也可以收到</li>
<li>但是在容器的eth0却收不到。按理说是veth pair，一端收到，另一端就肯定能收到。</li>
</ol>
<p>看来还有问题，需要继续定位</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于neutron做了一个容器网络方案，需要测试性能，用的iperf，但是在测试过程中，tcp/udp无法抵达跨节点的容器中&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="network" scheme="http://blog.decbug.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>山寨版sysdig cloud</title>
    <link href="http://blog.decbug.com/2016/12/06/sysdig_knockoff/"/>
    <id>http://blog.decbug.com/2016/12/06/sysdig_knockoff/</id>
    <published>2016-12-05T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.066Z</updated>
    
    <content type="html"><![CDATA[<p>调用链分析有三种模式：</p>
<ol>
<li>白盒，zipkin</li>
<li>灰盒，pinpoint，往JVM里注入</li>
<li>黑盒，优点是难度大，精度一般，优点是不用改代码</li>
</ol>
<p>之前分析的sysdig就算是黑盒,<a href="http://blog.decbug.com/2016/10/12/sysdig/">http://blog.decbug.com/2016/10/12/sysdig/</a>，恰好有需求说想不改代码，由容器云平台提供调用链分析。</p>
<p>参考了几篇论文及业内快讯之后，</p>
<ul>
<li>IBM的<a href="http://www.spark.tc/real-time-application-performance-profiling-using-spark/" target="_blank" rel="external">Real-time Performance Profiling &amp; Analytics for Microservices using Apache </a></li>
<li>MIT的<a href="https://pdos.csail.mit.edu/~athicha/papers/blackboxes:sosp03.pdf" target="_blank" rel="external">Performance Debugging for Distributed Systems of Black Boxes</a></li>
</ul>
<p>花了一周时间在k8s上做出来了，当然，由于缺乏算法支持，目前只做到了点对点的调用topo及http的时延。</p>
<a id="more"></a>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><ul>
<li>用开源sysdig做采集</li>
<li>参考http_log和memorycache，自己写了个Chisel做过滤分析</li>
<li>过滤后的日志print到std output，然后打到起了syslog的logstash容器</li>
<li>logstack到elastic search</li>
<li>之后写个可视化的web服务，根据用户的查询条件，把对应的topo及时延画出来，就可以辅助诊断性能问题</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调用链分析有三种模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;白盒，zipkin&lt;/li&gt;
&lt;li&gt;灰盒，pinpoint，往JVM里注入&lt;/li&gt;
&lt;li&gt;黑盒，优点是难度大，精度一般，优点是不用改代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前分析的sysdig就算是黑盒,&lt;a href=&quot;http://blog.decbug.com/2016/10/12/sysdig/&quot;&gt;http://blog.decbug.com/2016/10/12/sysdig/&lt;/a&gt;，恰好有需求说想不改代码，由容器云平台提供调用链分析。&lt;/p&gt;
&lt;p&gt;参考了几篇论文及业内快讯之后，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IBM的&lt;a href=&quot;http://www.spark.tc/real-time-application-performance-profiling-using-spark/&quot;&gt;Real-time Performance Profiling &amp;amp; Analytics for Microservices using Apache &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MIT的&lt;a href=&quot;https://pdos.csail.mit.edu/~athicha/papers/blackboxes:sosp03.pdf&quot;&gt;Performance Debugging for Distributed Systems of Black Boxes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;花了一周时间在k8s上做出来了，当然，由于缺乏算法支持，目前只做到了点对点的调用topo及http的时延。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
      <category term="tracing" scheme="http://blog.decbug.com/tags/tracing/"/>
    
  </entry>
  
  <entry>
    <title>阿里云容器服务分析</title>
    <link href="http://blog.decbug.com/2016/12/05/aliyun_container/"/>
    <id>http://blog.decbug.com/2016/12/05/aliyun_container/</id>
    <published>2016-12-04T17:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.062Z</updated>
    
    <content type="html"><![CDATA[<p>分析一下阿里云容器服务</p>
<a id="more"></a>
<h1 id="计算调度"><a href="#计算调度" class="headerlink" title="计算调度"></a>计算调度</h1><ul>
<li>swarm</li>
<li>用户先买几台虚拟机，之后在虚拟机上安装swarm</li>
<li>利用阿里云已有能力，在I层就实现了租户隔离</li>
<li>用户的集群规模不会很大，swarm的调度也能跟上</li>
<li>疑问：资源利用率？这不算是个PaaS吧<br><img src="http://dockerone.com/uploads/article/20160420/979b0743ac5f99e1467721b4cf6a8393.png" alt=""></li>
</ul>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><ul>
<li>阿里云vswitch, vrouter</li>
<li>利用阿里云已有IaaS的能力，不用overlay over overlay</li>
<li>性能好</li>
<li>其他容器厂商没有I层的能力，果然是大树底下好乘凉<br><img src="http://dockerone.com/uploads/article/20160420/cd9e52ae1faba951eabe808d2a1ffbf3.png" alt=""></li>
</ul>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><ul>
<li>扩展了plugin，可以接入OSS作为卷挂载到宿主机，之后mount到容器</li>
<li>依然是大树下好乘凉</li>
<li>卖容器的同时，还能卖OSS</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>可以接入阿里云的各种服务，如LB，redis，mysql</li>
<li>看来是想构建阿里云全家桶，可以卖出更多产品，很好的思路</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析一下阿里云容器服务&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="container" scheme="http://blog.decbug.com/tags/container/"/>
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>sudoers分析</title>
    <link href="http://blog.decbug.com/2016/12/05/sudoers/"/>
    <id>http://blog.decbug.com/2016/12/05/sudoers/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.066Z</updated>
    
    <content type="html"><![CDATA[<p>对于敏感命令，需要限制其使用范围，防止被攻击提权。至于如何提权，一搜就一大片例子，故不赘述。<br>为了解决此问题，需要找出系统用到了sudo的地方，然后把命令的具体参数都记录下来，写入到sudoers，避免使用其他参数。</p>
<a id="more"></a>
<h1 id="etc-sudoers"><a href="#etc-sudoers" class="headerlink" title="/etc/sudoers"></a>/etc/sudoers</h1><ul>
<li>需要用visudo打开，如果有语法错误，那么在保存时会有warning</li>
<li>行首是”%”的，表示是group，这一个group的全部用户都适用于这个sudo的定义；行首是用户名的，表示是用户。</li>
<li>注意特殊字符需要转义<code>The following characters must be escaped with a backslash (‘\’) when used as part of a word (e.g. a user name or host name): ‘!’, ‘=’, ‘:’, ‘,’, ‘(’, ‘)’, ‘\’.</code></li>
</ul>
<h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><p>以前的做法，看代码，找出全部用到sudo的脚本，代码等等。汇总之后写入到sudoers，耗时费力，大家苦不堪言，却没有想过改变。这次轮到我来干这类事，我觉得是在浪费生命，于是相处了偷懒的办法</p>
<ol>
<li>打开sudo的log，方法：在sudoers加上一行<code>Defaults          logfile=/var/log/sudo.log</code></li>
<li>之后运行我们的系统，一段时间后，基本上全部命令都执行到了，log里保存了全部的sudo记录</li>
<li>分析过滤提取<code>/var/log/sudo.log</code>，就能找出我们系统用到的sudo相关命令</li>
<li>自动汇总，写入到/etc/sudoers</li>
</ol>
<p>以前需要N人天才能做完的是，我花了1天写代码，之后5分钟就搞定。节省了N多人力物力，可以把时间投入到更有技术含量的工作中去。</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于敏感命令，需要限制其使用范围，防止被攻击提权。至于如何提权，一搜就一大片例子，故不赘述。&lt;br&gt;为了解决此问题，需要找出系统用到了sudo的地方，然后把命令的具体参数都记录下来，写入到sudoers，避免使用其他参数。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="sudoers" scheme="http://blog.decbug.com/tags/sudoers/"/>
    
  </entry>
  
  <entry>
    <title>通过libcap抓包</title>
    <link href="http://blog.decbug.com/2016/10/16/libcap/"/>
    <id>http://blog.decbug.com/2016/10/16/libcap/</id>
    <published>2016-10-15T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.066Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/5423628/19422110/910d9144-9441-11e6-87e8-a5919a41d8b1.png" alt="image"></p>
<p>原理</p>
<a id="more"></a>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19422117/a283aa58-9441-11e6-9276-16e9ba0ded25.png" alt="image"></p>
<p>用的是libcap抓的ip及len都不对，于是不用普罗米修斯模式，len对了，但是ip还是不对。继续分析。</p>
<p>把抓到的首部都打出来，和用tcpdump抓到的进行比较，内容一致，那么说明抓包正确，只是我的解析代码不对</p>
<p>由于inet_ntoa是静态buffer，所以第二次和第一次一样，改成inet_ntop就好了，因为不是静态buffer</p>
<p>收获挺大，把ip和tcp首部的每个字节都搞明白了</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/Seiyagoo/archive/2012/04/28/2475618.html" target="_blank" rel="external">http://www.cnblogs.com/Seiyagoo/archive/2012/04/28/2475618.html</a><br><a href="http://www.tcpdump.org/" target="_blank" rel="external">http://www.tcpdump.org/</a><br><a href="http://recursos.aldabaknocking.com/libpcapHakin9LuisMartinGarcia.pdf" target="_blank" rel="external">http://recursos.aldabaknocking.com/libpcapHakin9LuisMartinGarcia.pdf</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5423628/19422110/910d9144-9441-11e6-87e8-a5919a41d8b1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;原理&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="tcpdump" scheme="http://blog.decbug.com/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>调用链技术分析</title>
    <link href="http://blog.decbug.com/2016/10/14/tracing/"/>
    <id>http://blog.decbug.com/2016/10/14/tracing/</id>
    <published>2016-10-13T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.070Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371598/083f6f56-91e7-11e6-8964-63f4780885f1.png" alt="分布式调用"></p>
<p>都源于google的dapper，常见的有三种方式</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>概要</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>自己打日志</td>
<td>请求进入时生成ID，每次跨节点调用都带上ID，日志也打上ID</td>
<td>自己实现（这个算不算优点）</td>
<td>麻烦</td>
</tr>
<tr>
<td>用开源库，如zipkin</td>
<td>原理都差不多，都是ID spanID parentID</td>
<td>简单，client和server都有例子</td>
<td>需要集成</td>
</tr>
<tr>
<td>改分布式框架，如鹰眼，京东改dubbo</td>
<td>不用侵入业务代码，在框架里做好埋点和日志</td>
<td>自己实现</td>
<td>稍微麻烦，需要自己改框架</td>
</tr>
<tr>
<td>运行环境注入</td>
<td>例如<a href="https://newrelic.com/" target="_blank" rel="external">newrelic</a>，<a href="https://github.com/naver/pinpoint" target="_blank" rel="external">pinpoint</a>，改JVM运行时bytecode</td>
<td>非侵入</td>
<td>性能损耗比较大</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h1 id="dapper论文"><a href="#dapper论文" class="headerlink" title="dapper论文"></a>dapper论文</h1><p><img src="https://cloud.githubusercontent.com/assets/5423628/19371479/05ebe2b2-91e6-11e6-9a89-9827415d9464.png" alt="image"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371503/288995bc-91e6-11e6-9e68-8b198725a8a8.png" alt="image"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371519/3f05e1e2-91e6-11e6-84cf-77c2f095ff74.png" alt="image"></p>
<h1 id="zipkin"><a href="#zipkin" class="headerlink" title="zipkin"></a>zipkin</h1><p>在公司体验了一下，流程和<a href="https://yq.aliyun.com/articles/60165?spm=5176.100244.teamconlist.33.wxgYuD" target="_blank" rel="external">https://yq.aliyun.com/articles/60165?spm=5176.100244.teamconlist.33.wxgYuD</a><br>差不多</p>
<h1 id="改造分布式框架"><a href="#改造分布式框架" class="headerlink" title="改造分布式框架"></a>改造分布式框架</h1><p>在发远程调用，收到远程调用的时候，框架自身记录下来<br>实现起来想必不容易，但收益很大</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5423628/19371598/083f6f56-91e7-11e6-8964-63f4780885f1.png&quot; alt=&quot;分布式调用&quot;&gt;&lt;/p&gt;
&lt;p&gt;都源于google的dapper，常见的有三种方式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;自己打日志&lt;/td&gt;
&lt;td&gt;请求进入时生成ID，每次跨节点调用都带上ID，日志也打上ID&lt;/td&gt;
&lt;td&gt;自己实现（这个算不算优点）&lt;/td&gt;
&lt;td&gt;麻烦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用开源库，如zipkin&lt;/td&gt;
&lt;td&gt;原理都差不多，都是ID spanID parentID&lt;/td&gt;
&lt;td&gt;简单，client和server都有例子&lt;/td&gt;
&lt;td&gt;需要集成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;改分布式框架，如鹰眼，京东改dubbo&lt;/td&gt;
&lt;td&gt;不用侵入业务代码，在框架里做好埋点和日志&lt;/td&gt;
&lt;td&gt;自己实现&lt;/td&gt;
&lt;td&gt;稍微麻烦，需要自己改框架&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;运行环境注入&lt;/td&gt;
&lt;td&gt;例如&lt;a href=&quot;https://newrelic.com/&quot;&gt;newrelic&lt;/a&gt;，&lt;a href=&quot;https://github.com/naver/pinpoint&quot;&gt;pinpoint&lt;/a&gt;，改JVM运行时bytecode&lt;/td&gt;
&lt;td&gt;非侵入&lt;/td&gt;
&lt;td&gt;性能损耗比较大&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>sysdig源码分析</title>
    <link href="http://blog.decbug.com/2016/10/12/sysdig/"/>
    <id>http://blog.decbug.com/2016/10/12/sysdig/</id>
    <published>2016-10-11T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.066Z</updated>
    
    <content type="html"><![CDATA[<p>之前分析APM的时候，试用了sysdig，觉得sysdig很厉害</p>
<ol>
<li>通过内核抓事件，不用侵入到容器</li>
<li>可以自己写铲子，扩展起来很方便。<br>于是就顺手看下他的实现原理</li>
</ol>
<a id="more"></a>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/draios/sysdig" target="_blank" rel="external">https://github.com/draios/sysdig</a></p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><img src="http://www.plantuml.com/plantuml/svg/NOzB3i8m34JtFOML1MgHk0Ai4E8C1Q7G3gs5vQ8wV4zFa_8JondRyyRvjA3PR4vkhHpO2pzyu4vTbYNNxbPpGpqQje2US866zx1gsI2vd7r1dUvuIDWe6SBkm1At9qcO-fCWHevdH_GA-KJnWTorPG6j49RHN3WABJGZYjNAEsmxmBp8tbT7gbmQp7-jLEJh9nahlHXZq3yPOiZYHQdT0C2DNv-LIwrP6phrNGKRuFcqU080">
<h1 id="chisels的原理"><a href="#chisels的原理" class="headerlink" title="chisels的原理"></a>chisels的原理</h1><p>安装之后会在/usr/share/sysdig/chisels，看下memcachelog这个铲子的代码<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Initialization callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on_init</span><span class="params">()</span></span></span><br><span class="line">    util = &#123;&#125;</span><br><span class="line">    start_time = <span class="built_in">os</span>.time()</span><br><span class="line">    sysdig.set_filter(<span class="string">"(fd.sport=11211 or proc.name=memcached) and evt.is_io=true"</span>)</span><br><span class="line">    sysdig.set_snaplen(<span class="number">4096</span>)</span><br><span class="line">    data = chisel.request_field(<span class="string">"evt.arg[1]"</span>)</span><br><span class="line">    datetime = chisel.request_field(<span class="string">"evt.datetime"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Event callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on_event</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> data = evt.field(data)</span><br><span class="line">  <span class="keyword">local</span> line = split(data, <span class="string">" "</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">string</span>.match(line[<span class="number">1</span>], <span class="string">'^[gs]et'</span>) ~= <span class="keyword">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> method = line[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">local</span> key = line[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">local</span> size = <span class="built_in">tonumber</span>(line[<span class="number">5</span>]) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> key ~= <span class="keyword">nil</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> opt_method ~= <span class="keyword">nil</span> <span class="keyword">and</span> opt_method ~= method <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> opt_method == <span class="string">'set'</span> <span class="keyword">and</span> size &lt; opt_size <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">string</span>.format(<span class="string">"%s method=%s size=%dB key=%s"</span>,</span><br><span class="line">              evt.field(datetime),</span><br><span class="line">              method,</span><br><span class="line">              size,</span><br><span class="line">              key</span><br><span class="line">      ))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>on_init 设置filter，以及需要哪些data field</p>
<p>on_event，获取参数，得到method，是get/set，以及key</p>
<h1 id="sysdig原理"><a href="#sysdig原理" class="headerlink" title="sysdig原理"></a>sysdig原理</h1><p><code>driver/event_table.c</code> 事件都在这里g_event_info</p>
<p><code>driver/ppm_fillers.c</code> g_ppm_events事件的回调</p>
<p><code>userspace/libsinsp/chisel_api.cpp</code> lua_cbacks这个类是，lua调用c代码的接口</p>
<p>疑问：</p>
<ol>
<li>当事件发生，如何通过g_ppm_events里的回调函数再调用到lua里的on_event</li>
<li>event_table里的事件是如何发送到内核的？用到哪个API？是不是和systemtap差不多？</li>
</ol>
<p>晚上回家继续看看</p>
<h2 id="event-table里的事件是如何发送到内核的"><a href="#event-table里的事件是如何发送到内核的" class="headerlink" title="event_table里的事件是如何发送到内核的"></a>event_table里的事件是如何发送到内核的</h2><p>event_table里的事件是如何发送到内核的？用到哪个API？是不是和systemtap差不多？<br>翻了下源码，终于找到了<br>sysdig_init-&gt;get_tracepoint_handler-&gt;g_ppm_fops-&gt;ppm_open-&gt;compat_register-&gt;TRACEPOINT_PROBE_REGISTER-&gt;内核的tracepoint_probe_register</p>
<p>两个参数，一个是tracepoint name,另一个则是回调</p>
<h1 id="slideshare上的流程"><a href="#slideshare上的流程" class="headerlink" title="slideshare上的流程"></a>slideshare上的流程</h1><p><img src="https://cloud.githubusercontent.com/assets/5423628/19371219/091e8342-91e4-11e6-8a53-f2e597860efb.png" alt="syscall"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371250/40b1dd72-91e4-11e6-97c8-29ac829afde8.png" alt="event_collector"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371280/6b0da6be-91e4-11e6-9c9b-77b151f8428c.png" alt="container"></p>
<p><a href="http://www.slideshare.net/SreenivasMakam/container-monitoring-with-sysdig-58790785" target="_blank" rel="external">http://www.slideshare.net/SreenivasMakam/container-monitoring-with-sysdig-58790785</a></p>
<p><a href="http://www.slideshare.net/Sysdig/sysdig-meetup-dec2014" target="_blank" rel="external">http://www.slideshare.net/Sysdig/sysdig-meetup-dec2014</a></p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysdig <span class="operator">-l</span> <span class="comment"># 查看所有field</span></span><br><span class="line">sysdig -L <span class="comment"># 进事件，出事件的参数</span></span><br></pre></td></tr></table></figure>
<p>关注 fd.name, proc.name, fd.cip/sip/port/lip, datetime时间戳, fd.num标识唯一的一次连接, containername/ID, pid, tid</p>
<p>还有个tracer没太搞明白，里边有span等等，有时间再研究下</p>
<h1 id="其他内核trace"><a href="#其他内核trace" class="headerlink" title="其他内核trace"></a>其他内核trace</h1><table>
<thead>
<tr>
<th>时间</th>
<th>名字</th>
<th>主要技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>2000</td>
<td>Linux Trace Toolkit (LTT)</td>
<td></td>
</tr>
<tr>
<td>2005</td>
<td>LInux Trace Toolkit Next Generation (LTTng)</td>
<td></td>
</tr>
<tr>
<td>2008</td>
<td>Tracepoint</td>
<td>后面就用这个比较多？</td>
</tr>
<tr>
<td>xxxx</td>
<td>systemTAP</td>
<td>貌似也是用tracepoint probe</td>
</tr>
<tr>
<td>xxxx</td>
<td>ftrace</td>
<td>也是tracepoint</td>
</tr>
</tbody>
</table>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前分析APM的时候，试用了sysdig，觉得sysdig很厉害&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过内核抓事件，不用侵入到容器&lt;/li&gt;
&lt;li&gt;可以自己写铲子，扩展起来很方便。&lt;br&gt;于是就顺手看下他的实现原理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>APM厂商分析</title>
    <link href="http://blog.decbug.com/2016/10/10/APM/"/>
    <id>http://blog.decbug.com/2016/10/10/APM/</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.062Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务大行其道的今天，系统的实例越来越多，出现性能问题时要调试就很困难。于是乎，就出现了许多APM厂商，只需要装一个agent，就能通过监控系统调用，网络传输，性能指标，辅助调试定位性能问题。</p>
<p>在公司分析了很多，也抓包了，详细内容带不出来。就简单记个笔记，供以后回忆</p>
<a id="more"></a>
<h1 id="sysdig"><a href="#sysdig" class="headerlink" title="sysdig"></a>sysdig</h1><p>分为<a href="https://github.com/draios/sysdig" target="_blank" rel="external">开源版sysdig.org</a>和<a href="https://sysdig.com/" target="_blank" rel="external">商业版sysdig cloud</a></p>
<h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>原理：抓内核级别的调用，比如read，write，网络也是read，write，只不过描述符不一样，然后形成事件，记录下来<br>还有个强大的功能Chisel，很好玩，可以自己扩展功能，用lua写<br><a href="https://github.com/draios/sysdig/wiki/Writing-a-Sysdig-Chisel,-a-Tutorial" target="_blank" rel="external">Writing a Sysdig Chisel, a Tutorial</a></p>
<h2 id="sysdig-cloud"><a href="#sysdig-cloud" class="headerlink" title="sysdig cloud"></a>sysdig cloud</h2><p>装一个agent，用的是开源的sysdig采集数据，然后上报到sysdig cloud的服务器。</p>
<ul>
<li>可以展示topo，调用耗时等等</li>
<li>分析http，可以精确到url</li>
<li>通过分析开源代码，分析出具体的调用，原理应该和chisel中的memcache差不多</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>dynatrace &amp; apptrace<br>都差不多</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微服务大行其道的今天，系统的实例越来越多，出现性能问题时要调试就很困难。于是乎，就出现了许多APM厂商，只需要装一个agent，就能通过监控系统调用，网络传输，性能指标，辅助调试定位性能问题。&lt;/p&gt;
&lt;p&gt;在公司分析了很多，也抓包了，详细内容带不出来。就简单记个笔记，供以后回忆&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>容器分布式存储之Flocker</title>
    <link href="http://blog.decbug.com/2016/10/10/Flocker/"/>
    <id>http://blog.decbug.com/2016/10/10/Flocker/</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.062Z</updated>
    
    <content type="html"><![CDATA[<p>容器的分布式存储都差不多，都是docker daemon-&gt;plugin-&gt;agent-&gt;control，话说cinder也差不多。<br>正好看到了flocker，简单了解一下架构，记录下来加深印象</p>
<a id="more"></a>
<h1 id="flocker"><a href="#flocker" class="headerlink" title="flocker"></a>flocker</h1><p><img src="https://uploads.disquscdn.com/images/b891c982b375e67d8f6e22030c0404e86e3ea54c2f086be24e54dbd921d62e97.png" alt=""></p>
<h1 id="手绘架构图"><a href="#手绘架构图" class="headerlink" title="手绘架构图"></a>手绘架构图</h1><p><img src="https://uploads.disquscdn.com/images/edf315d6c61c5b6ef839fbd8513ebb7969f91d36d87984062f9a779601ba0e10.jpg" alt=""></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器的分布式存储都差不多，都是docker daemon-&amp;gt;plugin-&amp;gt;agent-&amp;gt;control，话说cinder也差不多。&lt;br&gt;正好看到了flocker，简单了解一下架构，记录下来加深印象&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="distributed storage" scheme="http://blog.decbug.com/tags/distributed-storage/"/>
    
  </entry>
  
  <entry>
    <title>VxLan原理</title>
    <link href="http://blog.decbug.com/2016/10/09/VxLan/"/>
    <id>http://blog.decbug.com/2016/10/09/VxLan/</id>
    <published>2016-10-08T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.062Z</updated>
    
    <content type="html"><![CDATA[<p>VxLan，网络虚拟化，应用很广泛</p>
<p>简单记录一下原理</p>
<a id="more"></a>
<p><img src="http://www.aboutyun.com/data/attachment/forum/201501/12/200932g95t3x5zlllv0cn3.jpg" alt="Frame Format"></p>
<p><img src="http://www.aboutyun.com/data/attachment/forum/201501/12/201142n2mmll72er7pldlp.jpg" alt=""></p>
<ol>
<li>VM1发送IP数据包到VM2，即192.168.0.100 到 192.168.0.101；</li>
<li>VTEP1查找自己的VXLAN表知道要发给VTEP2，然后依次封装以下数据包头；<ul>
<li>VXLAN包头</li>
<li>标准UDP包头，校验和checksum为0x0000；</li>
<li>标准IP包头，目标地址为VTEP2的IP地址，协议号设为0x11表面为UDP包。</li>
<li>标准MAC数据包，目标地址为下一跳设备的MAC地址00:10:11:FE:D8:D2，可路由到目标隧道端VTEP2。</li>
</ul>
</li>
<li>VTEP2接收数据包，根据UDP的destination端口找到VXLAN数据包。接着查找所有所在VXLAN的VNI为864的端口组，找到VM2的</li>
<li>VM2接收并处理数据包，拿到Payload数据。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.aboutyun.com/thread-11189-1-1.html" target="_blank" rel="external">http://www.aboutyun.com/thread-11189-1-1.html</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VxLan，网络虚拟化，应用很广泛&lt;/p&gt;
&lt;p&gt;简单记录一下原理&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="VxLan" scheme="http://blog.decbug.com/tags/VxLan/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统调度算法的公平</title>
    <link href="http://blog.decbug.com/2016/09/30/scheduler_fair/"/>
    <id>http://blog.decbug.com/2016/09/30/scheduler_fair/</id>
    <published>2016-09-29T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.066Z</updated>
    
    <content type="html"><![CDATA[<p>调度，在计算机世界里随处可见，只要有资源抢占，就需要调度。</p>
<p><img src="http://a3.att.hudong.com/78/47/01300000763638128366476399672.jpg" alt="无调度"></p>
<p><img src="http://img.www.zyue.com/news/2011/04/06/201104060829106892011040202.jpg" alt="有调度"></p>
<a id="more"></a>
<h1 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h1><p>操作系统要调度一堆进程，也是离不开调度算法的，linux喜欢用CFS，这里可以稍微扩展记录一下，加深印象</p>
<h1 id="分布式系统的调度"><a href="#分布式系统的调度" class="headerlink" title="分布式系统的调度"></a>分布式系统的调度</h1><p>公平与不公平<br>所谓公平，就是人人有饭吃，不能有人饿死</p>
<h2 id="不公平"><a href="#不公平" class="headerlink" title="不公平"></a>不公平</h2><ul>
<li>job1先来，job1有很多个task，就开始执行job1的task</li>
<li>之后job2过来，但是job1的task还没执行完，那么job2就要一直等待，这就叫饥饿</li>
</ul>
<h2 id="公平"><a href="#公平" class="headerlink" title="公平"></a>公平</h2><p>公平就是，大家都有饭吃</p>
<ul>
<li>job1先来，job1有很多个task，开始执行job1的task</li>
<li>然后job2过来，这时候job1的task还有一些没有执行完</li>
<li>调度器就会block job1，也就是说，会把job1剩余的task挂起</li>
<li>开始执行job2的task</li>
<li>一段时间后，由于job1饥饿了，所以又把job2 block，执行job1的task</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调度，在计算机世界里随处可见，只要有资源抢占，就需要调度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://a3.att.hudong.com/78/47/01300000763638128366476399672.jpg&quot; alt=&quot;无调度&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.www.zyue.com/news/2011/04/06/201104060829106892011040202.jpg&quot; alt=&quot;有调度&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="fair" scheme="http://blog.decbug.com/tags/fair/"/>
    
      <category term="scheduler" scheme="http://blog.decbug.com/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP ping ssh</title>
    <link href="http://blog.decbug.com/2016/09/09/ping_ssh/"/>
    <id>http://blog.decbug.com/2016/09/09/ping_ssh/</id>
    <published>2016-09-08T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.066Z</updated>
    
    <content type="html"><![CDATA[<p>数据库部署在k8s上，两个pod一主一备，却无法同步，一直同步失败，提示socket 什么什么什么。据同事说，还有一个现象是ping都会报错</p>
<a id="more"></a>
<h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><p>我看了下ping的报错,说permission啥啥啥的，于是谷歌一下，找到答案。是因为权限问题，用<strong>chmod u+s /bin/ping</strong>解决。</p>
<h1 id="能ping通，为何还是传输有问题"><a href="#能ping通，为何还是传输有问题" class="headerlink" title="能ping通，为何还是传输有问题"></a>能ping通，为何还是传输有问题</h1><p>因为ping是ICMP协议，基于IP层，能ping说，说明IP层是好的，无法确定TCP正常</p>
<h1 id="尝试用SSH测试TCP是否正常"><a href="#尝试用SSH测试TCP是否正常" class="headerlink" title="尝试用SSH测试TCP是否正常"></a>尝试用SSH测试TCP是否正常</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssh -vvv [ip]</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 返回</span></span><br><span class="line">debug1: Connection established.</span><br><span class="line"></span><br><span class="line">debug1: Local version <span class="built_in">string</span> SSH-<span class="number">2.0</span>-OpenSSH_6<span class="number">.6</span><span class="number">.1</span>p1 Ubuntu-<span class="number">2u</span>buntu2<span class="number">.8</span></span><br><span class="line">debug1: Remote protocol version <span class="number">2.0</span>, remote software version OpenSSH_6<span class="number">.6</span><span class="number">.1</span>p1 Ubuntu-<span class="number">2u</span>buntu2</span><br><span class="line">debug1: match: OpenSSH_6<span class="number">.6</span><span class="number">.1</span>p1 Ubuntu-<span class="number">2u</span>buntu2 pat OpenSSH_6<span class="number">.6</span><span class="number">.1</span>* compat <span class="number">0x04000000</span></span><br><span class="line"></span><br><span class="line">debug1: SSH2_MSG_KEXINIT sent</span><br></pre></td></tr></table></figure>
<ol>
<li>在<code>SSH2_MSG_KEXINIT</code>之后就没有了响应，</li>
<li><code>debug1: Connection established.</code>说明tcp连接建立成功</li>
<li>版本协商<ul>
<li><code>debug1: Local version string SSH-2.0-OpenSSH_6.6.1p1 Ubuntu-2ubuntu2.8</code>，本地ssh版本</li>
<li><code>debug1: Remote protocol version 2.0, remote software version OpenSSH_6.6.1p1 Ubuntu-2ubuntu2</code>，远端版本</li>
<li><code>debug1: match: OpenSSH_6.6.1p1 Ubuntu-2ubuntu2 pat OpenSSH_6.6.1* compat 0x04000000</code></li>
<li>说明成功通信一次</li>
</ul>
</li>
<li><code>debug1: SSH2_MSG_KEXINIT sent</code>，开始进行key的协商，然后就没有然后了</li>
</ol>
<p>后面的定位过程，就涉及到容器组网方案，不适合公开。</p>
<h1 id="顺便理解一下SSH协议"><a href="#顺便理解一下SSH协议" class="headerlink" title="顺便理解一下SSH协议"></a>顺便理解一下SSH协议</h1><p><img src="https://github.com/CodeJuan/blog/raw/master/source/image/ssh/capture.png" alt="capture"></p>
<ol>
<li>6,7,8握手</li>
<li>9,11协议协商阶段</li>
<li>16，17,20,23,24交换密钥阶段</li>
<li>认证阶段</li>
<li>会话</li>
</ol>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库部署在k8s上，两个pod一主一备，却无法同步，一直同步失败，提示socket 什么什么什么。据同事说，还有一个现象是ping都会报错&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="TCPIP" scheme="http://blog.decbug.com/tags/TCPIP/"/>
    
      <category term="protocol" scheme="http://blog.decbug.com/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>随手记录DHCP</title>
    <link href="http://blog.decbug.com/2016/08/29/dhcp/"/>
    <id>http://blog.decbug.com/2016/08/29/dhcp/</id>
    <published>2016-08-28T16:00:00.000Z</published>
    <updated>2017-02-24T14:20:19.062Z</updated>
    
    <content type="html"><![CDATA[<p>同事用PXE装系统，在装完最小系统后，会再次获取IP，然而DHCP却给了一个不一样的IP</p>
<a id="more"></a>
<h1 id="网上别人抓的正常包"><a href="#网上别人抓的正常包" class="headerlink" title="网上别人抓的正常包"></a>网上别人抓的正常包</h1><p><img src="https://github.com/CodeJuan/blog/raw/master/source/image/dhcp/pxe_dhcp_normal.jpg" alt="get"><br>可以看到</p>
<ol>
<li>装miniOS之前Discover,offer,request,ack</li>
<li>完成miniOS之后，request,ack</li>
</ol>
<h1 id="同事抓的包"><a href="#同事抓的包" class="headerlink" title="同事抓的包"></a>同事抓的包</h1><p>没有办法带出公司，只能凭记忆</p>
<ol>
<li>装miniOS之前Discover,offer,request,ack</li>
<li>完成miniOS之后，<strong>Discover,offer</strong>,request,ack</li>
<li>由于Discover了两次，所以得到了两个IP</li>
</ol>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>为什么会Discoverr两次？即使是Discover两次，那么对于同一个mac，DHCP也应该分配同样的IP吧？<br>DHCP的配置里有一个忽略clientID的参数</p>
<h1 id="复习DHCP流程"><a href="#复习DHCP流程" class="headerlink" title="复习DHCP流程"></a>复习DHCP流程</h1><p><img src="http://s3.51cto.com/wyfs02/M02/7B/63/wKioL1bM12-TVB73AAKfYIzxVJg695.png" alt=""></p>
<blockquote>
<p>参考<a href="http://tasnrh.blog.51cto.com/4141731/1744495" target="_blank" rel="external">http://tasnrh.blog.51cto.com/4141731/1744495</a><br><strong>DHCP发现（DISCOVER）</strong><br>目标设备在物理子网上发送广播来寻找可用的服务器。网络管理员可以配置一个本地路由来转发DHCP包给另一个子网上的DHCP服务器。该目标设备实现生成一个目的地址为255.255.255.255或者一个子网广播地址的UDP包。<br><strong>DHCP提供（OFFER）</strong><br>当DHCP服务器收到一个来自目标设备的IP租约请求时，它会提供一个IP租约。DHCP为目标设备保留一个IP地址，然后通过网络单播一个DHCPOFFER消息给目标设备。该消息包含目标设备的MAC地址、服务器提供的IP地址、子网掩码、租期以及提供IP的DHCP服务器的IP。<br>服务器基于在CHADDR字段指定的目标设备硬件地址来检查配置。这里的服务器，10.1.1.1，将IP地址指定于YIADDR字段。<br><strong>DHCP请求（REQUEST）</strong><br>当目标设备PC收到一个IP租约提供时，它必须告诉所有其他的DHCP服务器它已经接受了一个租约提供。因此，该目标设备会发送一个DHCPREQUEST消息，其中包含提供租约的服务器的IP。当其他DHCP服务器收到了该消息后，它们会收回所有可能已提供给目标设备的租约。然后它们把曾经给目标设备保留的那个地址重新放回到可用地址池中，这样，它们就可以为其他计算机分配这个地址。任意数量的DHCP服务器都可以响应同一个IP租约请求，但是每一个目标设备网卡只能接受一个租约提供。<br><strong>DHCP确认（Acknowledge，ACK）</strong><br>当DHCP服务器收到来自目标设备的REQUEST消息后，它就开始了配置过程的最后阶段。这个响应阶段包括发送一个DHCPACK包给目标设备。这个包包含租期和目标设备可能请求的其他所有配置信息。这时候，TCP/IP配置过程就完成了。</p>
</blockquote>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同事用PXE装系统，在装完最小系统后，会再次获取IP，然而DHCP却给了一个不一样的IP&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="DHCP" scheme="http://blog.decbug.com/tags/DHCP/"/>
    
      <category term="wireshark" scheme="http://blog.decbug.com/tags/wireshark/"/>
    
  </entry>
  
</feed>
