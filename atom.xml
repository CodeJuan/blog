<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Continuous Learning</title>
  <subtitle>浮云一别后，流水十年间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.decbug.com/"/>
  <updated>2017-01-20T00:12:16.184Z</updated>
  <id>http://blog.decbug.com/</id>
  
  <author>
    <name>CodeJuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KVM的几种缓存模式</title>
    <link href="http://blog.decbug.com/2017/01/17/KVM_cache/"/>
    <id>http://blog.decbug.com/2017/01/17/KVM_cache/</id>
    <published>2017-01-16T17:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.184Z</updated>
    
    <content type="html"><![CDATA[<p>现象：</p>
<ol>
<li>虚拟机的IO性能比物理机/容器好？</li>
<li>容器和物理机差不多，这个很好理解，如果没有做IO limit，肯定和物理机相近</li>
<li>用的virsh disk-attach宿主机上的一个/dev/sdxxx，用的是default</li>
<li>顺序读写完爆物理机</li>
<li>随机读写从1K，4K，16K到1M都比物理机强，唯有64M的写比物理机差</li>
</ol>
<p>比较奇怪，需要分析一下</p>
<a id="more"></a>
<h1 id="改cache-mode"><a href="#改cache-mode" class="headerlink" title="改cache mode"></a>改cache mode</h1><blockquote>
<p>writethrough<br>writethrough mode is the default caching mode. With caching set to writethrough mode, the host page cache is enabled, but the disk write cache is disabled for the guest. Consequently, this caching mode ensures data integrity even if the applications and storage stack in the guest do not transfer data to permanent storage properly (either through fsync operations or file system barriers). Because the host page cache is enabled in this mode, the read performance for applications running in the guest is generally better. However, the write performance might be reduced because the disk write cache is disabled.<br>默认模式，认为host page开启，没有用disk cache，会保证数据可靠，写性能会差，读性能会好？</p>
<p>writeback<br>With caching set to writeback mode, both the host page cache and the disk write cache are enabled for the guest. Because of this, the I/O performance for applications running in the guest is good, but the data is not protected in a power failure. As a result, this caching mode is recommended only for temporary data where potential data loss is not a concern.<br>host page和disk cache都开启，性能最好，但在掉电时会有丢数据的风险</p>
<p>none<br>With caching mode set to none, the host page cache is disabled, but the disk write cache is enabled for the guest. In this mode, the write performance in the guest is optimal because write operations bypass the host page cache and go directly to the disk write cache. If the disk write cache is battery-backed, or if the applications or storage stack in the guest transfer data properly (either through fsync operations or file system barriers), then data integrity can be ensured. However, because the host page cache is disabled, the read performance in the guest would not be as good as in the modes where the host page cache is enabled, such as writethrough mode.<br>只开disk cache，不开host page，号称写性能最强，读一般</p>
<p>unsafe<br>Caching mode of unsafe ignores cache transfer operations completely. As its name implies, this caching mode should be used only for temporary data where data loss is not a concern. This mode can be useful for speeding up guest installations, but you should switch to another caching mode in production environments.<br>只写到缓存，不落盘，建议只保存临时数据</p>
</blockquote>
<p>改成none试了下，竟然性能都变差？按理说写性能会提升啊？</p>
<h1 id="host-page-cache对性能的影响"><a href="#host-page-cache对性能的影响" class="headerlink" title="host page cache对性能的影响"></a>host page cache对性能的影响</h1><ul>
<li>64M性能下降是因为cache被打穿？对于大块用direct IO性能更好？即使改成direct IO，那么也是只绕过guest os的page cache啊？此时用none会更好？然而实际上，none的性能不好。</li>
<li>只要有空闲，系统的cache buffer都会很大。物理机是128G内存，所以虚拟机的读写操作都在内存里完成？</li>
<li>小块性能好，因为都在内存里？</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>真的是缓存的原因？大丈夫？</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机的IO性能比物理机/容器好？&lt;/li&gt;
&lt;li&gt;容器和物理机差不多，这个很好理解，如果没有做IO limit，肯定和物理机相近&lt;/li&gt;
&lt;li&gt;用的virsh disk-attach宿主机上的一个/dev/sdxxx，用的是default&lt;/li&gt;
&lt;li&gt;顺序读写完爆物理机&lt;/li&gt;
&lt;li&gt;随机读写从1K，4K，16K到1M都比物理机强，唯有64M的写比物理机差&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比较奇怪，需要分析一下&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="KVM" scheme="http://blog.decbug.com/tags/KVM/"/>
    
      <category term="cache" scheme="http://blog.decbug.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>Neutron与容器网络</title>
    <link href="http://blog.decbug.com/2017/01/15/container_neutron/"/>
    <id>http://blog.decbug.com/2017/01/15/container_neutron/</id>
    <published>2017-01-14T17:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.188Z</updated>
    
    <content type="html"><![CDATA[<p>容器用Neutron组网，比Flannel和VPC router强的地方在于</p>
<ul>
<li>多租户，不同租户的容器可以运行在同一个宿主机上。<ol>
<li>Flannel没有租户隔离，</li>
<li>阿里云则是先用租户开虚拟机，利用I层的隔离，同一个虚拟机只能跑一个租户的容器</li>
</ol>
</li>
<li>性能，如果是部署在openstack发放的虚拟机上，则不用在overlay一层</li>
</ul>
<a id="more"></a>
<h1 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a>大概原理</h1><p>记录一下</p>
<ol>
<li>neutron create port</li>
<li>docker network create bridge xxxx， docker run -net=xxxx</li>
<li>管理xxxx的CIDR</li>
<li>bridge veth pair   &lt;—&gt; (port IP MAC) veth pair port的qbr上</li>
<li>dvr add : xxxx的CIDR nexthop 是一个neutron port</li>
</ol>
<p>在这个图上稍作修改<br><img src="http://img.blog.csdn.net/20141208150804139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FueGluZ2hlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="neutron组网"></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器用Neutron组网，比Flannel和VPC router强的地方在于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多租户，不同租户的容器可以运行在同一个宿主机上。&lt;ol&gt;
&lt;li&gt;Flannel没有租户隔离，&lt;/li&gt;
&lt;li&gt;阿里云则是先用租户开虚拟机，利用I层的隔离，同一个虚拟机只能跑一个租户的容器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;性能，如果是部署在openstack发放的虚拟机上，则不用在overlay一层&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="network" scheme="http://blog.decbug.com/tags/network/"/>
    
      <category term="neutron" scheme="http://blog.decbug.com/tags/neutron/"/>
    
      <category term="openstack" scheme="http://blog.decbug.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>一次容器网络问题debug</title>
    <link href="http://blog.decbug.com/2017/01/03/container_network_debug/"/>
    <id>http://blog.decbug.com/2017/01/03/container_network_debug/</id>
    <published>2017-01-02T17:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.188Z</updated>
    
    <content type="html"><![CDATA[<p>基于neutron做了一个容器网络方案，需要测试性能，用的iperf，但是在测试过程中，tcp/udp无法抵达跨节点的容器中</p>
<a id="more"></a>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>网络组好之后，跨宿主机的容器相互可以ping通，但是在用iperf测试的时候</p>
<ol>
<li>tcp：client端一直显示带宽为0，server端显示建立连接，但是一直显示收到0字节</li>
<li>udp：client端显示12G的带宽，server端只显示建立连接，但没有其他响应。</li>
</ol>
<p>顺便说一下一直以来对于VxLan的一个疑惑，VxLan是通过udp发送，那么如何保证数据可靠传输呢？是不是udp里封了tcp的包，如果udp丢失了数据</p>
<h1 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h1><ol>
<li>在容器A里起一个python SimpleHTTPServer，在容器B里curl这个server。A容器收到请求，并且响应，但是B容器没有收到响应</li>
<li>猜测是不是安全组的问题？于是neutron secure-group-create 端口从1到65535，ingress egress，tcp udp都加上，再次curl，还是不通</li>
<li>用tcpdump同时在server端和client端抓包，保存起来</li>
<li>在两个宿主机起python server，也curl一次并抓包</li>
<li>用wireshark对比两次的包，发现容器里curl多了一个1518 length的包，于是猜测是不是MTU的问题？因为之前在看flannel的时候，需要在docker启动参数上设置MTU为1450</li>
<li>分别在两个容器都设置mtu：ip netns 容器网络命名空间 ifconfig eth0 mtu 1400</li>
<li>再次curl，容器B收到响应</li>
<li>继续iperf，tcp的可以测通，性能和用neutron的虚拟机相似</li>
<li>但是udp还是不通</li>
<li>继续抓两个容器的docker0，可以收到数据</li>
<li>两个veth，也可以收到</li>
<li>但是在容器的eth0却收不到。按理说是veth pair，一端收到，另一端就肯定能收到。</li>
</ol>
<p>看来还有问题，需要继续定位</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于neutron做了一个容器网络方案，需要测试性能，用的iperf，但是在测试过程中，tcp/udp无法抵达跨节点的容器中&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="network" scheme="http://blog.decbug.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>山寨版sysdig cloud</title>
    <link href="http://blog.decbug.com/2016/12/06/sysdig_knockoff/"/>
    <id>http://blog.decbug.com/2016/12/06/sysdig_knockoff/</id>
    <published>2016-12-05T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.192Z</updated>
    
    <content type="html"><![CDATA[<p>调用链分析有三种模式：</p>
<ol>
<li>白盒，zipkin</li>
<li>灰盒，pinpoint，往JVM里注入</li>
<li>黑盒，优点是难度大，精度一般，优点是不用改代码</li>
</ol>
<p>之前分析的sysdig就算是黑盒,<a href="http://blog.decbug.com/2016/10/12/sysdig/">http://blog.decbug.com/2016/10/12/sysdig/</a>，恰好有需求说想不改代码，由容器云平台提供调用链分析。</p>
<p>参考了几篇论文及业内快讯之后，</p>
<ul>
<li>IBM的<a href="http://www.spark.tc/real-time-application-performance-profiling-using-spark/" target="_blank" rel="external">Real-time Performance Profiling &amp; Analytics for Microservices using Apache </a></li>
<li>MIT的<a href="https://pdos.csail.mit.edu/~athicha/papers/blackboxes:sosp03.pdf" target="_blank" rel="external">Performance Debugging for Distributed Systems of Black Boxes</a></li>
</ul>
<p>花了一周时间在k8s上做出来了，当然，由于缺乏算法支持，目前只做到了点对点的调用topo及http的时延。</p>
<a id="more"></a>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><ul>
<li>用开源sysdig做采集</li>
<li>参考http_log和memorycache，自己写了个Chisel做过滤分析</li>
<li>过滤后的日志print到std output，然后打到起了syslog的logstash容器</li>
<li>logstack到elastic search</li>
<li>之后写个可视化的web服务，根据用户的查询条件，把对应的topo及时延画出来，就可以辅助诊断性能问题</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调用链分析有三种模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;白盒，zipkin&lt;/li&gt;
&lt;li&gt;灰盒，pinpoint，往JVM里注入&lt;/li&gt;
&lt;li&gt;黑盒，优点是难度大，精度一般，优点是不用改代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前分析的sysdig就算是黑盒,&lt;a href=&quot;http://blog.decbug.com/2016/10/12/sysdig/&quot;&gt;http://blog.decbug.com/2016/10/12/sysdig/&lt;/a&gt;，恰好有需求说想不改代码，由容器云平台提供调用链分析。&lt;/p&gt;
&lt;p&gt;参考了几篇论文及业内快讯之后，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IBM的&lt;a href=&quot;http://www.spark.tc/real-time-application-performance-profiling-using-spark/&quot;&gt;Real-time Performance Profiling &amp;amp; Analytics for Microservices using Apache &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MIT的&lt;a href=&quot;https://pdos.csail.mit.edu/~athicha/papers/blackboxes:sosp03.pdf&quot;&gt;Performance Debugging for Distributed Systems of Black Boxes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;花了一周时间在k8s上做出来了，当然，由于缺乏算法支持，目前只做到了点对点的调用topo及http的时延。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
      <category term="tracing" scheme="http://blog.decbug.com/tags/tracing/"/>
    
  </entry>
  
  <entry>
    <title>阿里云容器服务分析</title>
    <link href="http://blog.decbug.com/2016/12/05/aliyun_container/"/>
    <id>http://blog.decbug.com/2016/12/05/aliyun_container/</id>
    <published>2016-12-04T17:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.184Z</updated>
    
    <content type="html"><![CDATA[<p>分析一下阿里云容器服务</p>
<a id="more"></a>
<h1 id="计算调度"><a href="#计算调度" class="headerlink" title="计算调度"></a>计算调度</h1><ul>
<li>swarm</li>
<li>用户先买几台虚拟机，之后在虚拟机上安装swarm</li>
<li>利用阿里云已有能力，在I层就实现了租户隔离</li>
<li>用户的集群规模不会很大，swarm的调度也能跟上</li>
<li>疑问：资源利用率？这不算是个PaaS吧<br><img src="http://dockerone.com/uploads/article/20160420/979b0743ac5f99e1467721b4cf6a8393.png" alt=""></li>
</ul>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><ul>
<li>阿里云vswitch, vrouter</li>
<li>利用阿里云已有IaaS的能力，不用overlay over overlay</li>
<li>性能好</li>
<li>其他容器厂商没有I层的能力，果然是大树底下好乘凉<br><img src="http://dockerone.com/uploads/article/20160420/cd9e52ae1faba951eabe808d2a1ffbf3.png" alt=""></li>
</ul>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><ul>
<li>扩展了plugin，可以接入OSS作为卷挂载到宿主机，之后mount到容器</li>
<li>依然是大树下好乘凉</li>
<li>卖容器的同时，还能卖OSS</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>可以接入阿里云的各种服务，如LB，redis，mysql</li>
<li>看来是想构建阿里云全家桶，可以卖出更多产品，很好的思路</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析一下阿里云容器服务&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="container" scheme="http://blog.decbug.com/tags/container/"/>
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>sudoers分析</title>
    <link href="http://blog.decbug.com/2016/12/05/sudoers/"/>
    <id>http://blog.decbug.com/2016/12/05/sudoers/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.192Z</updated>
    
    <content type="html"><![CDATA[<p>对于敏感命令，需要限制其使用范围，防止被攻击提权。至于如何提权，一搜就一大片例子，故不赘述。<br>为了解决此问题，需要找出系统用到了sudo的地方，然后把命令的具体参数都记录下来，写入到sudoers，避免使用其他参数。</p>
<a id="more"></a>
<h1 id="etc-sudoers"><a href="#etc-sudoers" class="headerlink" title="/etc/sudoers"></a>/etc/sudoers</h1><ul>
<li>需要用visudo打开，如果有语法错误，那么在保存时会有warning</li>
<li>行首是”%”的，表示是group，这一个group的全部用户都适用于这个sudo的定义；行首是用户名的，表示是用户。</li>
<li>注意特殊字符需要转义<code>The following characters must be escaped with a backslash (‘\’) when used as part of a word (e.g. a user name or host name): ‘!’, ‘=’, ‘:’, ‘,’, ‘(’, ‘)’, ‘\’.</code></li>
</ul>
<h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><p>以前的做法，看代码，找出全部用到sudo的脚本，代码等等。汇总之后写入到sudoers，耗时费力，大家苦不堪言，却没有想过改变。这次轮到我来干这类事，我觉得是在浪费生命，于是相处了偷懒的办法</p>
<ol>
<li>打开sudo的log，方法：在sudoers加上一行<code>Defaults          logfile=/var/log/sudo.log</code></li>
<li>之后运行我们的系统，一段时间后，基本上全部命令都执行到了，log里保存了全部的sudo记录</li>
<li>分析过滤提取<code>/var/log/sudo.log</code>，就能找出我们系统用到的sudo相关命令</li>
<li>自动汇总，写入到/etc/sudoers</li>
</ol>
<p>以前需要N人天才能做完的是，我花了1天写代码，之后5分钟就搞定。节省了N多人力物力，可以把时间投入到更有技术含量的工作中去。</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于敏感命令，需要限制其使用范围，防止被攻击提权。至于如何提权，一搜就一大片例子，故不赘述。&lt;br&gt;为了解决此问题，需要找出系统用到了sudo的地方，然后把命令的具体参数都记录下来，写入到sudoers，避免使用其他参数。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="sudoers" scheme="http://blog.decbug.com/tags/sudoers/"/>
    
  </entry>
  
  <entry>
    <title>通过libcap抓包</title>
    <link href="http://blog.decbug.com/2016/10/16/libcap/"/>
    <id>http://blog.decbug.com/2016/10/16/libcap/</id>
    <published>2016-10-15T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.188Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/5423628/19422110/910d9144-9441-11e6-87e8-a5919a41d8b1.png" alt="image"></p>
<p>原理</p>
<a id="more"></a>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19422117/a283aa58-9441-11e6-9276-16e9ba0ded25.png" alt="image"></p>
<p>用的是libcap抓的ip及len都不对，于是不用普罗米修斯模式，len对了，但是ip还是不对。继续分析。</p>
<p>把抓到的首部都打出来，和用tcpdump抓到的进行比较，内容一致，那么说明抓包正确，只是我的解析代码不对</p>
<p>由于inet_ntoa是静态buffer，所以第二次和第一次一样，改成inet_ntop就好了，因为不是静态buffer</p>
<p>收获挺大，把ip和tcp首部的每个字节都搞明白了</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/Seiyagoo/archive/2012/04/28/2475618.html" target="_blank" rel="external">http://www.cnblogs.com/Seiyagoo/archive/2012/04/28/2475618.html</a><br><a href="http://www.tcpdump.org/" target="_blank" rel="external">http://www.tcpdump.org/</a><br><a href="http://recursos.aldabaknocking.com/libpcapHakin9LuisMartinGarcia.pdf" target="_blank" rel="external">http://recursos.aldabaknocking.com/libpcapHakin9LuisMartinGarcia.pdf</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5423628/19422110/910d9144-9441-11e6-87e8-a5919a41d8b1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;原理&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="tcpdump" scheme="http://blog.decbug.com/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>调用链技术分析</title>
    <link href="http://blog.decbug.com/2016/10/14/tracing/"/>
    <id>http://blog.decbug.com/2016/10/14/tracing/</id>
    <published>2016-10-13T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.192Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371598/083f6f56-91e7-11e6-8964-63f4780885f1.png" alt="分布式调用"></p>
<p>都源于google的dapper，常见的有三种方式</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>概要</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>自己打日志</td>
<td>请求进入时生成ID，每次跨节点调用都带上ID，日志也打上ID</td>
<td>自己实现（这个算不算优点）</td>
<td>麻烦</td>
</tr>
<tr>
<td>用开源库，如zipkin</td>
<td>原理都差不多，都是ID spanID parentID</td>
<td>简单，client和server都有例子</td>
<td>需要集成</td>
</tr>
<tr>
<td>改分布式框架，如鹰眼，京东改dubbo</td>
<td>不用侵入业务代码，在框架里做好埋点和日志</td>
<td>自己实现</td>
<td>稍微麻烦，需要自己改框架</td>
</tr>
<tr>
<td>运行环境注入</td>
<td>例如<a href="https://newrelic.com/" target="_blank" rel="external">newrelic</a>，<a href="https://github.com/naver/pinpoint" target="_blank" rel="external">pinpoint</a>，改JVM运行时bytecode</td>
<td>非侵入</td>
<td>性能损耗比较大</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h1 id="dapper论文"><a href="#dapper论文" class="headerlink" title="dapper论文"></a>dapper论文</h1><p><img src="https://cloud.githubusercontent.com/assets/5423628/19371479/05ebe2b2-91e6-11e6-9a89-9827415d9464.png" alt="image"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371503/288995bc-91e6-11e6-9e68-8b198725a8a8.png" alt="image"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371519/3f05e1e2-91e6-11e6-84cf-77c2f095ff74.png" alt="image"></p>
<h1 id="zipkin"><a href="#zipkin" class="headerlink" title="zipkin"></a>zipkin</h1><p>在公司体验了一下，流程和<a href="https://yq.aliyun.com/articles/60165?spm=5176.100244.teamconlist.33.wxgYuD" target="_blank" rel="external">https://yq.aliyun.com/articles/60165?spm=5176.100244.teamconlist.33.wxgYuD</a><br>差不多</p>
<h1 id="改造分布式框架"><a href="#改造分布式框架" class="headerlink" title="改造分布式框架"></a>改造分布式框架</h1><p>在发远程调用，收到远程调用的时候，框架自身记录下来<br>实现起来想必不容易，但收益很大</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/5423628/19371598/083f6f56-91e7-11e6-8964-63f4780885f1.png&quot; alt=&quot;分布式调用&quot;&gt;&lt;/p&gt;
&lt;p&gt;都源于google的dapper，常见的有三种方式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;自己打日志&lt;/td&gt;
&lt;td&gt;请求进入时生成ID，每次跨节点调用都带上ID，日志也打上ID&lt;/td&gt;
&lt;td&gt;自己实现（这个算不算优点）&lt;/td&gt;
&lt;td&gt;麻烦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用开源库，如zipkin&lt;/td&gt;
&lt;td&gt;原理都差不多，都是ID spanID parentID&lt;/td&gt;
&lt;td&gt;简单，client和server都有例子&lt;/td&gt;
&lt;td&gt;需要集成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;改分布式框架，如鹰眼，京东改dubbo&lt;/td&gt;
&lt;td&gt;不用侵入业务代码，在框架里做好埋点和日志&lt;/td&gt;
&lt;td&gt;自己实现&lt;/td&gt;
&lt;td&gt;稍微麻烦，需要自己改框架&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;运行环境注入&lt;/td&gt;
&lt;td&gt;例如&lt;a href=&quot;https://newrelic.com/&quot;&gt;newrelic&lt;/a&gt;，&lt;a href=&quot;https://github.com/naver/pinpoint&quot;&gt;pinpoint&lt;/a&gt;，改JVM运行时bytecode&lt;/td&gt;
&lt;td&gt;非侵入&lt;/td&gt;
&lt;td&gt;性能损耗比较大&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>sysdig源码分析</title>
    <link href="http://blog.decbug.com/2016/10/12/sysdig/"/>
    <id>http://blog.decbug.com/2016/10/12/sysdig/</id>
    <published>2016-10-11T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.192Z</updated>
    
    <content type="html"><![CDATA[<p>之前分析APM的时候，试用了sysdig，觉得sysdig很厉害</p>
<ol>
<li>通过内核抓事件，不用侵入到容器</li>
<li>可以自己写铲子，扩展起来很方便。<br>于是就顺手看下他的实现原理</li>
</ol>
<a id="more"></a>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/draios/sysdig" target="_blank" rel="external">https://github.com/draios/sysdig</a></p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><img src="http://www.plantuml.com/plantuml/svg/NOzB3i8m34JtFOML1MgHk0Ai4E8C1Q7G3gs5vQ8wV4zFa_8JondRyyRvjA3PR4vkhHpO2pzyu4vTbYNNxbPpGpqQje2US866zx1gsI2vd7r1dUvuIDWe6SBkm1At9qcO-fCWHevdH_GA-KJnWTorPG6j49RHN3WABJGZYjNAEsmxmBp8tbT7gbmQp7-jLEJh9nahlHXZq3yPOiZYHQdT0C2DNv-LIwrP6phrNGKRuFcqU080">
<h1 id="chisels的原理"><a href="#chisels的原理" class="headerlink" title="chisels的原理"></a>chisels的原理</h1><p>安装之后会在/usr/share/sysdig/chisels，看下memcachelog这个铲子的代码<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Initialization callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on_init</span><span class="params">()</span></span></span><br><span class="line">    util = &#123;&#125;</span><br><span class="line">    start_time = <span class="built_in">os</span>.time()</span><br><span class="line">    sysdig.set_filter(<span class="string">"(fd.sport=11211 or proc.name=memcached) and evt.is_io=true"</span>)</span><br><span class="line">    sysdig.set_snaplen(<span class="number">4096</span>)</span><br><span class="line">    data = chisel.request_field(<span class="string">"evt.arg[1]"</span>)</span><br><span class="line">    datetime = chisel.request_field(<span class="string">"evt.datetime"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Event callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on_event</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> data = evt.field(data)</span><br><span class="line">  <span class="keyword">local</span> line = split(data, <span class="string">" "</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">string</span>.match(line[<span class="number">1</span>], <span class="string">'^[gs]et'</span>) ~= <span class="keyword">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> method = line[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">local</span> key = line[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">local</span> size = <span class="built_in">tonumber</span>(line[<span class="number">5</span>]) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> key ~= <span class="keyword">nil</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> opt_method ~= <span class="keyword">nil</span> <span class="keyword">and</span> opt_method ~= method <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> opt_method == <span class="string">'set'</span> <span class="keyword">and</span> size &lt; opt_size <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="built_in">string</span>.format(<span class="string">"%s method=%s size=%dB key=%s"</span>,</span><br><span class="line">              evt.field(datetime),</span><br><span class="line">              method,</span><br><span class="line">              size,</span><br><span class="line">              key</span><br><span class="line">      ))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>on_init 设置filter，以及需要哪些data field</p>
<p>on_event，获取参数，得到method，是get/set，以及key</p>
<h1 id="sysdig原理"><a href="#sysdig原理" class="headerlink" title="sysdig原理"></a>sysdig原理</h1><p><code>driver/event_table.c</code> 事件都在这里g_event_info</p>
<p><code>driver/ppm_fillers.c</code> g_ppm_events事件的回调</p>
<p><code>userspace/libsinsp/chisel_api.cpp</code> lua_cbacks这个类是，lua调用c代码的接口</p>
<p>疑问：</p>
<ol>
<li>当事件发生，如何通过g_ppm_events里的回调函数再调用到lua里的on_event</li>
<li>event_table里的事件是如何发送到内核的？用到哪个API？是不是和systemtap差不多？</li>
</ol>
<p>晚上回家继续看看</p>
<h2 id="event-table里的事件是如何发送到内核的"><a href="#event-table里的事件是如何发送到内核的" class="headerlink" title="event_table里的事件是如何发送到内核的"></a>event_table里的事件是如何发送到内核的</h2><p>event_table里的事件是如何发送到内核的？用到哪个API？是不是和systemtap差不多？<br>翻了下源码，终于找到了<br>sysdig_init-&gt;get_tracepoint_handler-&gt;g_ppm_fops-&gt;ppm_open-&gt;compat_register-&gt;TRACEPOINT_PROBE_REGISTER-&gt;内核的tracepoint_probe_register</p>
<p>两个参数，一个是tracepoint name,另一个则是回调</p>
<h1 id="slideshare上的流程"><a href="#slideshare上的流程" class="headerlink" title="slideshare上的流程"></a>slideshare上的流程</h1><p><img src="https://cloud.githubusercontent.com/assets/5423628/19371219/091e8342-91e4-11e6-8a53-f2e597860efb.png" alt="syscall"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371250/40b1dd72-91e4-11e6-97c8-29ac829afde8.png" alt="event_collector"></p>
<p><img src="https://cloud.githubusercontent.com/assets/5423628/19371280/6b0da6be-91e4-11e6-9c9b-77b151f8428c.png" alt="container"></p>
<p><a href="http://www.slideshare.net/SreenivasMakam/container-monitoring-with-sysdig-58790785" target="_blank" rel="external">http://www.slideshare.net/SreenivasMakam/container-monitoring-with-sysdig-58790785</a></p>
<p><a href="http://www.slideshare.net/Sysdig/sysdig-meetup-dec2014" target="_blank" rel="external">http://www.slideshare.net/Sysdig/sysdig-meetup-dec2014</a></p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysdig <span class="operator">-l</span> <span class="comment"># 查看所有field</span></span><br><span class="line">sysdig -L <span class="comment"># 进事件，出事件的参数</span></span><br></pre></td></tr></table></figure>
<p>关注 fd.name, proc.name, fd.cip/sip/port/lip, datetime时间戳, fd.num标识唯一的一次连接, containername/ID, pid, tid</p>
<p>还有个tracer没太搞明白，里边有span等等，有时间再研究下</p>
<h1 id="其他内核trace"><a href="#其他内核trace" class="headerlink" title="其他内核trace"></a>其他内核trace</h1><table>
<thead>
<tr>
<th>时间</th>
<th>名字</th>
<th>主要技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>2000</td>
<td>Linux Trace Toolkit (LTT)</td>
<td></td>
</tr>
<tr>
<td>2005</td>
<td>LInux Trace Toolkit Next Generation (LTTng)</td>
<td></td>
</tr>
<tr>
<td>2008</td>
<td>Tracepoint</td>
<td>后面就用这个比较多？</td>
</tr>
<tr>
<td>xxxx</td>
<td>systemTAP</td>
<td>貌似也是用tracepoint probe</td>
</tr>
<tr>
<td>xxxx</td>
<td>ftrace</td>
<td>也是tracepoint</td>
</tr>
</tbody>
</table>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前分析APM的时候，试用了sysdig，觉得sysdig很厉害&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过内核抓事件，不用侵入到容器&lt;/li&gt;
&lt;li&gt;可以自己写铲子，扩展起来很方便。&lt;br&gt;于是就顺手看下他的实现原理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>容器分布式存储之Flocker</title>
    <link href="http://blog.decbug.com/2016/10/10/Flocker/"/>
    <id>http://blog.decbug.com/2016/10/10/Flocker/</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.184Z</updated>
    
    <content type="html"><![CDATA[<p>容器的分布式存储都差不多，都是docker daemon-&gt;plugin-&gt;agent-&gt;control，话说cinder也差不多。<br>正好看到了flocker，简单了解一下架构，记录下来加深印象</p>
<a id="more"></a>
<h1 id="flocker"><a href="#flocker" class="headerlink" title="flocker"></a>flocker</h1><p><img src="https://uploads.disquscdn.com/images/b891c982b375e67d8f6e22030c0404e86e3ea54c2f086be24e54dbd921d62e97.png" alt=""></p>
<h1 id="手绘架构图"><a href="#手绘架构图" class="headerlink" title="手绘架构图"></a>手绘架构图</h1><p><img src="https://uploads.disquscdn.com/images/edf315d6c61c5b6ef839fbd8513ebb7969f91d36d87984062f9a779601ba0e10.jpg" alt=""></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器的分布式存储都差不多，都是docker daemon-&amp;gt;plugin-&amp;gt;agent-&amp;gt;control，话说cinder也差不多。&lt;br&gt;正好看到了flocker，简单了解一下架构，记录下来加深印象&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="distributed storage" scheme="http://blog.decbug.com/tags/distributed-storage/"/>
    
  </entry>
  
  <entry>
    <title>APM厂商分析</title>
    <link href="http://blog.decbug.com/2016/10/10/APM/"/>
    <id>http://blog.decbug.com/2016/10/10/APM/</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.184Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务大行其道的今天，系统的实例越来越多，出现性能问题时要调试就很困难。于是乎，就出现了许多APM厂商，只需要装一个agent，就能通过监控系统调用，网络传输，性能指标，辅助调试定位性能问题。</p>
<p>在公司分析了很多，也抓包了，详细内容带不出来。就简单记个笔记，供以后回忆</p>
<a id="more"></a>
<h1 id="sysdig"><a href="#sysdig" class="headerlink" title="sysdig"></a>sysdig</h1><p>分为<a href="https://github.com/draios/sysdig" target="_blank" rel="external">开源版sysdig.org</a>和<a href="https://sysdig.com/" target="_blank" rel="external">商业版sysdig cloud</a></p>
<h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>原理：抓内核级别的调用，比如read，write，网络也是read，write，只不过描述符不一样，然后形成事件，记录下来<br>还有个强大的功能Chisel，很好玩，可以自己扩展功能，用lua写<br><a href="https://github.com/draios/sysdig/wiki/Writing-a-Sysdig-Chisel,-a-Tutorial" target="_blank" rel="external">Writing a Sysdig Chisel, a Tutorial</a></p>
<h2 id="sysdig-cloud"><a href="#sysdig-cloud" class="headerlink" title="sysdig cloud"></a>sysdig cloud</h2><p>装一个agent，用的是开源的sysdig采集数据，然后上报到sysdig cloud的服务器。</p>
<ul>
<li>可以展示topo，调用耗时等等</li>
<li>分析http，可以精确到url</li>
<li>通过分析开源代码，分析出具体的调用，原理应该和chisel中的memcache差不多</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>dynatrace &amp; apptrace<br>都差不多</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微服务大行其道的今天，系统的实例越来越多，出现性能问题时要调试就很困难。于是乎，就出现了许多APM厂商，只需要装一个agent，就能通过监控系统调用，网络传输，性能指标，辅助调试定位性能问题。&lt;/p&gt;
&lt;p&gt;在公司分析了很多，也抓包了，详细内容带不出来。就简单记个笔记，供以后回忆&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="APM" scheme="http://blog.decbug.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>VxLan原理</title>
    <link href="http://blog.decbug.com/2016/10/09/VxLan/"/>
    <id>http://blog.decbug.com/2016/10/09/VxLan/</id>
    <published>2016-10-08T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.184Z</updated>
    
    <content type="html"><![CDATA[<p>VxLan，网络虚拟化，应用很广泛</p>
<p>简单记录一下原理</p>
<a id="more"></a>
<p><img src="http://www.aboutyun.com/data/attachment/forum/201501/12/200932g95t3x5zlllv0cn3.jpg" alt="Frame Format"></p>
<p><img src="http://www.aboutyun.com/data/attachment/forum/201501/12/201142n2mmll72er7pldlp.jpg" alt=""></p>
<ol>
<li>VM1发送IP数据包到VM2，即192.168.0.100 到 192.168.0.101；</li>
<li>VTEP1查找自己的VXLAN表知道要发给VTEP2，然后依次封装以下数据包头；<ul>
<li>VXLAN包头</li>
<li>标准UDP包头，校验和checksum为0x0000；</li>
<li>标准IP包头，目标地址为VTEP2的IP地址，协议号设为0x11表面为UDP包。</li>
<li>标准MAC数据包，目标地址为下一跳设备的MAC地址00:10:11:FE:D8:D2，可路由到目标隧道端VTEP2。</li>
</ul>
</li>
<li>VTEP2接收数据包，根据UDP的destination端口找到VXLAN数据包。接着查找所有所在VXLAN的VNI为864的端口组，找到VM2的</li>
<li>VM2接收并处理数据包，拿到Payload数据。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.aboutyun.com/thread-11189-1-1.html" target="_blank" rel="external">http://www.aboutyun.com/thread-11189-1-1.html</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VxLan，网络虚拟化，应用很广泛&lt;/p&gt;
&lt;p&gt;简单记录一下原理&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="VxLan" scheme="http://blog.decbug.com/tags/VxLan/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统调度算法的公平</title>
    <link href="http://blog.decbug.com/2016/09/30/scheduler_fair/"/>
    <id>http://blog.decbug.com/2016/09/30/scheduler_fair/</id>
    <published>2016-09-29T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.192Z</updated>
    
    <content type="html"><![CDATA[<p>调度，在计算机世界里随处可见，只要有资源抢占，就需要调度。</p>
<p><img src="http://a3.att.hudong.com/78/47/01300000763638128366476399672.jpg" alt="无调度"></p>
<p><img src="http://img.www.zyue.com/news/2011/04/06/201104060829106892011040202.jpg" alt="有调度"></p>
<a id="more"></a>
<h1 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h1><p>操作系统要调度一堆进程，也是离不开调度算法的，linux喜欢用CFS，这里可以稍微扩展记录一下，加深印象</p>
<h1 id="分布式系统的调度"><a href="#分布式系统的调度" class="headerlink" title="分布式系统的调度"></a>分布式系统的调度</h1><p>公平与不公平<br>所谓公平，就是人人有饭吃，不能有人饿死</p>
<h2 id="不公平"><a href="#不公平" class="headerlink" title="不公平"></a>不公平</h2><ul>
<li>job1先来，job1有很多个task，就开始执行job1的task</li>
<li>之后job2过来，但是job1的task还没执行完，那么job2就要一直等待，这就叫饥饿</li>
</ul>
<h2 id="公平"><a href="#公平" class="headerlink" title="公平"></a>公平</h2><p>公平就是，大家都有饭吃</p>
<ul>
<li>job1先来，job1有很多个task，开始执行job1的task</li>
<li>然后job2过来，这时候job1的task还有一些没有执行完</li>
<li>调度器就会block job1，也就是说，会把job1剩余的task挂起</li>
<li>开始执行job2的task</li>
<li>一段时间后，由于job1饥饿了，所以又把job2 block，执行job1的task</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调度，在计算机世界里随处可见，只要有资源抢占，就需要调度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://a3.att.hudong.com/78/47/01300000763638128366476399672.jpg&quot; alt=&quot;无调度&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.www.zyue.com/news/2011/04/06/201104060829106892011040202.jpg&quot; alt=&quot;有调度&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="fair" scheme="http://blog.decbug.com/tags/fair/"/>
    
      <category term="scheduler" scheme="http://blog.decbug.com/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP ping ssh</title>
    <link href="http://blog.decbug.com/2016/09/09/ping_ssh/"/>
    <id>http://blog.decbug.com/2016/09/09/ping_ssh/</id>
    <published>2016-09-08T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.192Z</updated>
    
    <content type="html"><![CDATA[<p>数据库部署在k8s上，两个pod一主一备，却无法同步，一直同步失败，提示socket 什么什么什么。据同事说，还有一个现象是ping都会报错</p>
<a id="more"></a>
<h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><p>我看了下ping的报错,说permission啥啥啥的，于是谷歌一下，找到答案。是因为权限问题，用<strong>chmod u+s /bin/ping</strong>解决。</p>
<h1 id="能ping通，为何还是传输有问题"><a href="#能ping通，为何还是传输有问题" class="headerlink" title="能ping通，为何还是传输有问题"></a>能ping通，为何还是传输有问题</h1><p>因为ping是ICMP协议，基于IP层，能ping说，说明IP层是好的，无法确定TCP正常</p>
<h1 id="尝试用SSH测试TCP是否正常"><a href="#尝试用SSH测试TCP是否正常" class="headerlink" title="尝试用SSH测试TCP是否正常"></a>尝试用SSH测试TCP是否正常</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssh -vvv [ip]</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 返回</span></span><br><span class="line">debug1: Connection established.</span><br><span class="line"></span><br><span class="line">debug1: Local version <span class="built_in">string</span> SSH-<span class="number">2.0</span>-OpenSSH_6<span class="number">.6</span><span class="number">.1</span>p1 Ubuntu-<span class="number">2u</span>buntu2<span class="number">.8</span></span><br><span class="line">debug1: Remote protocol version <span class="number">2.0</span>, remote software version OpenSSH_6<span class="number">.6</span><span class="number">.1</span>p1 Ubuntu-<span class="number">2u</span>buntu2</span><br><span class="line">debug1: match: OpenSSH_6<span class="number">.6</span><span class="number">.1</span>p1 Ubuntu-<span class="number">2u</span>buntu2 pat OpenSSH_6<span class="number">.6</span><span class="number">.1</span>* compat <span class="number">0x04000000</span></span><br><span class="line"></span><br><span class="line">debug1: SSH2_MSG_KEXINIT sent</span><br></pre></td></tr></table></figure>
<ol>
<li>在<code>SSH2_MSG_KEXINIT</code>之后就没有了响应，</li>
<li><code>debug1: Connection established.</code>说明tcp连接建立成功</li>
<li>版本协商<ul>
<li><code>debug1: Local version string SSH-2.0-OpenSSH_6.6.1p1 Ubuntu-2ubuntu2.8</code>，本地ssh版本</li>
<li><code>debug1: Remote protocol version 2.0, remote software version OpenSSH_6.6.1p1 Ubuntu-2ubuntu2</code>，远端版本</li>
<li><code>debug1: match: OpenSSH_6.6.1p1 Ubuntu-2ubuntu2 pat OpenSSH_6.6.1* compat 0x04000000</code></li>
<li>说明成功通信一次</li>
</ul>
</li>
<li><code>debug1: SSH2_MSG_KEXINIT sent</code>，开始进行key的协商，然后就没有然后了</li>
</ol>
<p>后面的定位过程，就涉及到容器组网方案，不适合公开。</p>
<h1 id="顺便理解一下SSH协议"><a href="#顺便理解一下SSH协议" class="headerlink" title="顺便理解一下SSH协议"></a>顺便理解一下SSH协议</h1><p><img src="https://github.com/CodeJuan/blog/raw/master/source/image/ssh/capture.png" alt="capture"></p>
<ol>
<li>6,7,8握手</li>
<li>9,11协议协商阶段</li>
<li>16，17,20,23,24交换密钥阶段</li>
<li>认证阶段</li>
<li>会话</li>
</ol>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库部署在k8s上，两个pod一主一备，却无法同步，一直同步失败，提示socket 什么什么什么。据同事说，还有一个现象是ping都会报错&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="TCPIP" scheme="http://blog.decbug.com/tags/TCPIP/"/>
    
      <category term="protocol" scheme="http://blog.decbug.com/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>随手记录DHCP</title>
    <link href="http://blog.decbug.com/2016/08/29/dhcp/"/>
    <id>http://blog.decbug.com/2016/08/29/dhcp/</id>
    <published>2016-08-28T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.188Z</updated>
    
    <content type="html"><![CDATA[<p>同事用PXE装系统，在装完最小系统后，会再次获取IP，然而DHCP却给了一个不一样的IP</p>
<a id="more"></a>
<h1 id="网上别人抓的正常包"><a href="#网上别人抓的正常包" class="headerlink" title="网上别人抓的正常包"></a>网上别人抓的正常包</h1><p><img src="https://github.com/CodeJuan/blog/raw/master/source/image/dhcp/pxe_dhcp_normal.jpg" alt="get"><br>可以看到</p>
<ol>
<li>装miniOS之前Discover,offer,request,ack</li>
<li>完成miniOS之后，request,ack</li>
</ol>
<h1 id="同事抓的包"><a href="#同事抓的包" class="headerlink" title="同事抓的包"></a>同事抓的包</h1><p>没有办法带出公司，只能凭记忆</p>
<ol>
<li>装miniOS之前Discover,offer,request,ack</li>
<li>完成miniOS之后，<strong>Discover,offer</strong>,request,ack</li>
<li>由于Discover了两次，所以得到了两个IP</li>
</ol>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>为什么会Discoverr两次？即使是Discover两次，那么对于同一个mac，DHCP也应该分配同样的IP吧？<br>DHCP的配置里有一个忽略clientID的参数</p>
<h1 id="复习DHCP流程"><a href="#复习DHCP流程" class="headerlink" title="复习DHCP流程"></a>复习DHCP流程</h1><p><img src="http://s3.51cto.com/wyfs02/M02/7B/63/wKioL1bM12-TVB73AAKfYIzxVJg695.png" alt=""></p>
<blockquote>
<p>参考<a href="http://tasnrh.blog.51cto.com/4141731/1744495" target="_blank" rel="external">http://tasnrh.blog.51cto.com/4141731/1744495</a><br><strong>DHCP发现（DISCOVER）</strong><br>目标设备在物理子网上发送广播来寻找可用的服务器。网络管理员可以配置一个本地路由来转发DHCP包给另一个子网上的DHCP服务器。该目标设备实现生成一个目的地址为255.255.255.255或者一个子网广播地址的UDP包。<br><strong>DHCP提供（OFFER）</strong><br>当DHCP服务器收到一个来自目标设备的IP租约请求时，它会提供一个IP租约。DHCP为目标设备保留一个IP地址，然后通过网络单播一个DHCPOFFER消息给目标设备。该消息包含目标设备的MAC地址、服务器提供的IP地址、子网掩码、租期以及提供IP的DHCP服务器的IP。<br>服务器基于在CHADDR字段指定的目标设备硬件地址来检查配置。这里的服务器，10.1.1.1，将IP地址指定于YIADDR字段。<br><strong>DHCP请求（REQUEST）</strong><br>当目标设备PC收到一个IP租约提供时，它必须告诉所有其他的DHCP服务器它已经接受了一个租约提供。因此，该目标设备会发送一个DHCPREQUEST消息，其中包含提供租约的服务器的IP。当其他DHCP服务器收到了该消息后，它们会收回所有可能已提供给目标设备的租约。然后它们把曾经给目标设备保留的那个地址重新放回到可用地址池中，这样，它们就可以为其他计算机分配这个地址。任意数量的DHCP服务器都可以响应同一个IP租约请求，但是每一个目标设备网卡只能接受一个租约提供。<br><strong>DHCP确认（Acknowledge，ACK）</strong><br>当DHCP服务器收到来自目标设备的REQUEST消息后，它就开始了配置过程的最后阶段。这个响应阶段包括发送一个DHCPACK包给目标设备。这个包包含租期和目标设备可能请求的其他所有配置信息。这时候，TCP/IP配置过程就完成了。</p>
</blockquote>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同事用PXE装系统，在装完最小系统后，会再次获取IP，然而DHCP却给了一个不一样的IP&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="DHCP" scheme="http://blog.decbug.com/tags/DHCP/"/>
    
      <category term="wireshark" scheme="http://blog.decbug.com/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>通过故事谈消息队列</title>
    <link href="http://blog.decbug.com/2016/08/23/sth_about_MQ/"/>
    <id>http://blog.decbug.com/2016/08/23/sth_about_MQ/</id>
    <published>2016-08-22T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.192Z</updated>
    
    <content type="html"><![CDATA[<p>通过简单的例子，讲故事的方式解释消息队列</p>
<a id="more"></a>
<p>我们在做架构设计的时候，我个人理解，有一点很重要，叫各司其职。<br>如何才算各司其职呢？首先，你得让他们各自有职责，才有职可依。<br>比如说，举个不恰当的例子，以前没有数据库的时候，我们要吧数据持久化，可能需要自己写文件，自己写查找算法。后面大家觉得自己存取数据太麻烦，而且不通用，于是就想办法专门做一个模块来存取数据。<br>这个，就是职责划分产生的必然结果。</p>
<p>故事</p>
<ul>
<li>在很久很久以前，人们住得很近，所谓鸡犬之声相闻，邻居之间有个啥事需要帮忙，吼一声，大家都能听到，就会帮你做事。</li>
<li>再后来，村庄变城市，大家住的越来越远，家庭的独立性越来越强，相互之间再通过吼一声来已然不现实，所以，就有了电话。想让对方帮忙，足不出户，一个电话就能通知到。</li>
<li>但是，你想要对方帮忙，还得知道电话号码，如果换号码了也没有通知到你，那么你就无法找对方帮忙了。于是乎，就出了信使这个职业。你只要告诉信使，你需要人来做某某事，信使就会把你的任务通知到所有能做这个事的人。收到任务的人，就会去做，做完之后他就告诉信使已完成，信使再告诉你结果。</li>
</ul>
<p>对应到计算机世界</p>
<ul>
<li>在同一个进程，想调用别人，知道接口就行。对应的是村庄时代</li>
<li>再后来，单机性能不够，所以，就需要拆分到多个机器。比如，数据库就部署到单独的机器，别人通过远程调用来使用。对应的是电话时代</li>
<li>再后来，集群时代到来，于是消息队列就红红火火恍恍惚惚。对应信使时代</li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过简单的例子，讲故事的方式解释消息队列&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="MQ" scheme="http://blog.decbug.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础知识--namespace cgroup</title>
    <link href="http://blog.decbug.com/2016/08/15/docker_basic/"/>
    <id>http://blog.decbug.com/2016/08/15/docker_basic/</id>
    <published>2016-08-14T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.188Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下docker基础知识</p>
<p>namespace是环境隔离，cgroup是资源隔离，加起来就是docker的基础</p>
<a id="more"></a>
<h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><ol>
<li>CLONE_NEWPID</li>
<li>CLONE_NEWUTS</li>
<li>CLONE_NEWNS</li>
<li>CLONE_NEWIPC</li>
<li>CLONE_NEWNET</li>
<li>CLONE_NEWUSER</li>
</ol>
<h2 id="不带namespace"><a href="#不带namespace" class="headerlink" title="不带namespace"></a>不带namespace</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程堆栈空间大小</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_SIZE (<span class="number">1024</span> * <span class="number">1024</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_cmd[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child start!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child pid in child process: %5d\n"</span>, getpid());</span><br><span class="line">    <span class="comment">//使用bash替换掉原进程便于观察</span></span><br><span class="line">    execv(child_cmd[<span class="number">0</span>], child_cmd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child stop!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent start!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent pid: %5d\n"</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child, child_stack+STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child pid in parent process: %5d\n"</span>, child_pid);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent stop!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i3@i3:~/code/namespace$ ./base</span><br><span class="line">Parent <span class="operator"><span class="keyword">start</span>!</span><br><span class="line"><span class="keyword">Parent</span> pid:  <span class="number">7816</span></span><br><span class="line"><span class="keyword">Child</span> pid <span class="keyword">in</span> <span class="keyword">parent</span> process:  <span class="number">7817</span></span><br><span class="line"><span class="keyword">Child</span> <span class="keyword">start</span>!</span><br><span class="line"><span class="keyword">Child</span> pid <span class="keyword">in</span> <span class="keyword">child</span> process:  <span class="number">7817</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="UTS"><a href="#UTS" class="headerlink" title="UTS"></a>UTS</h2><h1 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://yq.aliyun.com/articles/57743" target="_blank" rel="external">https://yq.aliyun.com/articles/57743</a><br><a href="http://coolshell.cn/articles/17049.html" target="_blank" rel="external">http://coolshell.cn/articles/17049.html</a></p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下docker基础知识&lt;/p&gt;
&lt;p&gt;namespace是环境隔离，cgroup是资源隔离，加起来就是docker的基础&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="cgroup" scheme="http://blog.decbug.com/tags/cgroup/"/>
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="namespace" scheme="http://blog.decbug.com/tags/namespace/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes尝试有状态服务</title>
    <link href="http://blog.decbug.com/2016/08/03/k8s_stateful/"/>
    <id>http://blog.decbug.com/2016/08/03/k8s_stateful/</id>
    <published>2016-08-02T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有状态服务的概念"><a href="#有状态服务的概念" class="headerlink" title="有状态服务的概念"></a>有状态服务的概念</h1><p>既然名叫有状态，那么就与之相对，会有我们很熟悉的无状态。无状态的概念，就是只负责运算，不负责任何数据的存储，这样就能很轻松地做到水平扩展。</p>
<blockquote>
<p>之前写的关于无状态的例子</p>
</blockquote>
<p>那么，有状态的概念又是什么呢，简单来说，就是会有数据的存储，需要持久化。</p>
<a id="more"></a>
<h1 id="k8s的petset"><a href="#k8s的petset" class="headerlink" title="k8s的petset"></a>k8s的petset</h1><p>简单来说，pod是用来跑无状态服务，petset就是跑有状态服务。<br>1.3之前k8s大多是用于无状态的web应用，但是我们实际业务却有很多有状态的服务，对于谷歌来说，绝对不会放弃这一块的机会，所以petset就应运而生。</p>
<p>那么，作为有状态服务的基石，petset需要具备哪些特征呢：</p>
<ol>
<li>有唯一的编号</li>
<li>在网络上有个不会改变的标识，k8s是通过域名实现的。pod，则是名字后面还有随机数，所以需要有service来做转发</li>
<li>每个有状态服务，都需要有自己的卷，这样就能保证数据可靠存储</li>
</ol>
<h1 id="petset的典型场景"><a href="#petset的典型场景" class="headerlink" title="petset的典型场景"></a>petset的典型场景</h1><p>MySQL<br>Zookeeper<br>Cassandra<br>redis</p>
<h1 id="小试验"><a href="#小试验" class="headerlink" title="小试验"></a>小试验</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># A headless service to <span class="operator"><span class="keyword">create</span> DNS <span class="keyword">records</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  <span class="keyword">name</span>: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: <span class="number">80</span></span><br><span class="line">    <span class="keyword">name</span>: web</span><br><span class="line">  # *.nginx.<span class="keyword">default</span>.svc.cluster.<span class="keyword">local</span></span><br><span class="line">  clusterIP: <span class="keyword">None</span></span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">apiVersion: apps/v1alpha1</span><br><span class="line">kind: PetSet</span><br><span class="line">metadata:</span><br><span class="line">  <span class="keyword">name</span>: web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">"nginx"</span></span><br><span class="line">  replicas: <span class="number">2</span></span><br><span class="line">  <span class="keyword">template</span>:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">      annotations:</span><br><span class="line">        pod.alpha.kubernetes.io/<span class="keyword">initialized</span>: <span class="string">"true"</span></span><br><span class="line">    spec:</span><br><span class="line">      terminationGracePeriodSeconds: <span class="number">0</span></span><br><span class="line">      containers:</span><br><span class="line">      - <span class="keyword">name</span>: nginx</span><br><span class="line">        image: gcr.io/google_containers/nginx-slim:<span class="number">0.8</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">          <span class="keyword">name</span>: web</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - <span class="keyword">name</span>: www</span><br><span class="line">          mountPath: /usr/<span class="keyword">share</span>/nginx/html</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      <span class="keyword">name</span>: www</span><br><span class="line">      annotations:</span><br><span class="line">        volume.alpha.kubernetes.io/<span class="keyword">storage</span>-<span class="keyword">class</span>: anything</span><br><span class="line">    spec:</span><br><span class="line">      accessModes: [ <span class="string">"ReadWriteOnce"</span> ]</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          <span class="keyword">storage</span>: <span class="number">1</span>Gi</span></span><br></pre></td></tr></table></figure>
<p>提示<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./kubectl <span class="operator"><span class="keyword">describe</span> pvc www-web-<span class="number">0</span></span><br><span class="line"><span class="keyword">Name</span>:		www-web-<span class="number">0</span></span><br><span class="line">Namespace:	<span class="keyword">default</span></span><br><span class="line"><span class="keyword">Status</span>:		Pending</span><br><span class="line">Volume:</span><br><span class="line">Labels:		app=nginx</span><br><span class="line"><span class="keyword">Capacity</span>:</span><br><span class="line"><span class="keyword">Access</span> Modes:</span><br><span class="line"><span class="keyword">Events</span>:</span><br><span class="line">  FirstSeen	LastSeen	<span class="keyword">Count</span>	<span class="keyword">From</span>				SubobjectPath	<span class="keyword">Type</span>		Reason			Message</span><br><span class="line">  <span class="comment">---------	--------	-----	----				-------------	--------	------			-------</span></span><br><span class="line">  <span class="number">5</span><span class="keyword">m</span>		<span class="number">10</span>s		<span class="number">22</span>	&#123;persistentvolume-controller &#125;			<span class="keyword">Warning</span>		ProvisioningFailed	<span class="keyword">No</span> provisioner <span class="keyword">plugin</span> <span class="keyword">found</span> <span class="keyword">for</span> the claim!</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为需要设置<code>Persistent Volume Provisioning</code><br>方法是在controller manager的启动参数加上<code>--enable-hostpath-provisioner=true</code>，然后重启controller，再create就OK了。</p>
<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p><a href="https://github.com/kubernetes/kubernetes/tree/master/test/e2e/testing-manifests/petset/redis" target="_blank" rel="external">https://github.com/kubernetes/kubernetes/tree/master/test/e2e/testing-manifests/petset/redis</a></p>
<h2 id="service-yml"><a href="#service-yml" class="headerlink" title="service.yml"></a>service.yml</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># A headless service to <span class="operator"><span class="keyword">create</span> DNS <span class="keyword">records</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    service.alpha.kubernetes.io/tolerate-unready-endpoints: <span class="string">"true"</span></span><br><span class="line">  <span class="keyword">name</span>: redis</span><br><span class="line">  labels:</span><br><span class="line">    app: redis</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: <span class="number">6379</span></span><br><span class="line">    <span class="keyword">name</span>: peer</span><br><span class="line">  # *.redis.<span class="keyword">default</span>.svc.cluster.<span class="keyword">local</span></span><br><span class="line">  clusterIP: <span class="keyword">None</span></span><br><span class="line">  selector:</span><br><span class="line">    app: redis</span></span><br></pre></td></tr></table></figure>
<h2 id="petset-yml"><a href="#petset-yml" class="headerlink" title="petset.yml"></a>petset.yml</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1alpha1</span><br><span class="line">kind: PetSet</span><br><span class="line">metadata:</span><br><span class="line">  name: rd</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">"redis"</span></span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        <span class="keyword">app</span>: redis</span><br><span class="line">      annotations:</span><br><span class="line">        pod.<span class="keyword">alpha</span>.kubernetes.io/initialized: <span class="string">"true"</span></span><br><span class="line">        pod.<span class="keyword">alpha</span>.kubernetes.io/init-containers: '[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"install"</span>,</span><br><span class="line">                <span class="string">"image"</span>: <span class="string">"gcr.io/google_containers/redis-install-3.2.0:e2e"</span>,</span><br><span class="line">                <span class="string">"imagePullPolicy"</span>: <span class="string">"Always"</span>,</span><br><span class="line">                <span class="string">"args"</span>: [<span class="string">"--install-into=/opt"</span>, <span class="string">"--work-dir=/work-dir"</span>],</span><br><span class="line">                <span class="string">"volumeMounts"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"name"</span>: <span class="string">"opt"</span>,</span><br><span class="line">                        <span class="string">"mountPath"</span>: <span class="string">"/opt"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"name"</span>: <span class="string">"workdir"</span>,</span><br><span class="line">                        <span class="string">"mountPath"</span>: <span class="string">"/work-dir"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"bootstrap"</span>,</span><br><span class="line">                <span class="string">"image"</span>: <span class="string">"debian:jessie"</span>,</span><br><span class="line">                <span class="string">"command"</span>: [<span class="string">"/work-dir/peer-finder"</span>],</span><br><span class="line">                <span class="string">"args"</span>: [<span class="string">"-on-start=\"</span>/work-<span class="keyword">dir</span>/<span class="keyword">on</span>-start.<span class="keyword">sh</span>\<span class="string">""</span>, <span class="string">"-service=redis"</span>],</span><br><span class="line">                <span class="string">"env"</span>: [</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="string">"name"</span>: <span class="string">"POD_NAMESPACE"</span>,</span><br><span class="line">                      <span class="string">"valueFrom"</span>: &#123;</span><br><span class="line">                          <span class="string">"fieldRef"</span>: &#123;</span><br><span class="line">                              <span class="string">"apiVersion"</span>: <span class="string">"v1"</span>,</span><br><span class="line">                              <span class="string">"fieldPath"</span>: <span class="string">"metadata.namespace"</span></span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"volumeMounts"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"name"</span>: <span class="string">"opt"</span>,</span><br><span class="line">                        <span class="string">"mountPath"</span>: <span class="string">"/opt"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"name"</span>: <span class="string">"workdir"</span>,</span><br><span class="line">                        <span class="string">"mountPath"</span>: <span class="string">"/work-dir"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]'</span><br><span class="line">    spec:</span><br><span class="line">      terminationGracePeriodSeconds: 0</span><br><span class="line">      containers:</span><br><span class="line">      - name: redis</span><br><span class="line">        image: debian:jessie</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 6379</span><br><span class="line">          name: peer</span><br><span class="line">        command:</span><br><span class="line">        - /opt/redis/redis-server</span><br><span class="line">        <span class="keyword">args</span>:</span><br><span class="line">        - /opt/redis/redis.<span class="keyword">conf</span></span><br><span class="line">        readinessProbe:</span><br><span class="line">          exec:</span><br><span class="line">            command:</span><br><span class="line">            - <span class="keyword">sh</span></span><br><span class="line">            - -c</span><br><span class="line">            - <span class="string">"/opt/redis/redis-cli -h $(hostname) ping"</span></span><br><span class="line">          initialDelaySeconds: 15</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: datadir</span><br><span class="line">          mountPath: /data</span><br><span class="line">        - name: opt</span><br><span class="line">          mountPath: /opt</span><br><span class="line">      volumes:</span><br><span class="line">      - name: opt</span><br><span class="line">        emptyDir: &#123;&#125;</span><br><span class="line">      - name: workdir</span><br><span class="line">        emptyDir: &#123;&#125;</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: datadir</span><br><span class="line">      annotations:</span><br><span class="line">        volume.<span class="keyword">alpha</span>.kubernetes.io/storage-<span class="keyword">class</span>: anything</span><br><span class="line">    spec:</span><br><span class="line">      accessModes: [ <span class="string">"ReadWriteOnce"</span> ]</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.infoq.com/cn/news/2015/12/scaling-stateful-services" target="_blank" rel="external">构建可伸缩的有状态服务</a></li>
<li><a href="http://docs.alauda.cn/feature/service/stateless-service-and-stateful-service.html" target="_blank" rel="external">无状态服务 vs 有状态服务</a></li>
<li><a href="http://kubernetes.io/docs/user-guide/petset/" target="_blank" rel="external">Pet Sets</a></li>
</ul>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有状态服务的概念&quot;&gt;&lt;a href=&quot;#有状态服务的概念&quot; class=&quot;headerlink&quot; title=&quot;有状态服务的概念&quot;&gt;&lt;/a&gt;有状态服务的概念&lt;/h1&gt;&lt;p&gt;既然名叫有状态，那么就与之相对，会有我们很熟悉的无状态。无状态的概念，就是只负责运算，不负责任何数据的存储，这样就能很轻松地做到水平扩展。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之前写的关于无状态的例子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，有状态的概念又是什么呢，简单来说，就是会有数据的存储，需要持久化。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="kubernetes" scheme="http://blog.decbug.com/tags/kubernetes/"/>
    
      <category term="stateful" scheme="http://blog.decbug.com/tags/stateful/"/>
    
  </entry>
  
  <entry>
    <title>体验docker UCP</title>
    <link href="http://blog.decbug.com/2016/08/02/evaluate_docker_UCP/"/>
    <id>http://blog.decbug.com/2016/08/02/evaluate_docker_UCP/</id>
    <published>2016-08-01T16:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>docker官方也有私有云版本<br><a id="more"></a></p>
<h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><h2 id="docker-engine"><a href="#docker-engine" class="headerlink" title="docker engine"></a>docker engine</h2><p>感谢Daoloud提供的一键式安装<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL http<span class="variable">s:</span>//<span class="built_in">get</span>.daocloud.io/docker | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>
<h2 id="ucp"><a href="#ucp" class="headerlink" title="ucp"></a>ucp</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> DOCKER_TLS_VERIFY=<span class="string">"0"</span></span><br><span class="line"><span class="keyword">export</span> DOCKER_HOST=<span class="string">"tcp://104.236.158.191:2376"</span></span><br><span class="line"><span class="keyword">export</span> DOCKER_CERT_PATH=<span class="string">""</span></span><br><span class="line"><span class="keyword">export</span> DOCKER_MACHINE_NAME=<span class="string">"node1"</span></span><br><span class="line"></span><br><span class="line">docker run --rm -<span class="literal">it</span> <span class="string">\</span></span><br><span class="line">&gt; -v /<span class="keyword">var</span>/run/docker.<span class="attribute">sock</span>:/<span class="keyword">var</span>/run/docker.sock <span class="string">\</span></span><br><span class="line">&gt; --name ucp docker/ucp install -i <span class="string">\</span></span><br><span class="line">&gt; --swarm-port <span class="number">3376</span> --host-address <span class="number">104.236</span>.<span class="number">158.191</span></span><br></pre></td></tr></table></figure>
<p>提示<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could <span class="operator">not</span> <span class="built_in">read</span> CA certificate <span class="string">"/root/.docker/ca.pem"</span>: <span class="built_in">open</span> /root/.docker/ca.pem: no such <span class="built_in">file</span> <span class="operator">or</span> <span class="built_in">directory</span></span><br></pre></td></tr></table></figure></p>
<p>看来需要生成一个<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl req -out ca.pem -<span class="keyword">new</span> -x509</span><br><span class="line"><span class="preprocessor"># aaaa</span></span><br><span class="line"><span class="preprocessor"># <span class="number">104.236</span><span class="number">.158</span><span class="number">.191</span></span></span><br></pre></td></tr></table></figure></p>
<p>再次运行run<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Unable to find image 'docker/ucp:latest' locally</span><br><span class="line">latest: Pulling from docker/ucp</span><br><span class="line">e110a4a17941: Pull complete</span><br><span class="line">a1c3e1c9e147: Pull complete</span><br><span class="line">bca4748868da: Pull complete</span><br><span class="line">Digest: sha256:46154615e2429a9a8f3d019c414f69cd47f9f7dd5d5c35f54016c01fad1d99ef</span><br><span class="line">Status: Downloaded newer image for docker/ucp:latest</span><br><span class="line">INFO[0000] Verifying your system is compatible with UCP</span><br><span class="line">INFO[0000] Your engine version 1.12.0, build 8eab29e (4.4.0-31-generic) is compatible</span><br><span class="line">WARN[0000] Your system does not have enough memory.  UCP suggests a minimum of 2.00 GB, but you only have 0.97 GB.  You may have unexpected errors.</span><br><span class="line">Please choose your initial UCP admin password:</span><br><span class="line">Confirm your initial password:</span><br><span class="line">INFO[0024] Pulling required images... (this may take a while)</span><br><span class="line">WARN[0080] None of the hostnames we'll be using in the UCP certificates [ubuntu-1gb-sfo1-01 127.0.0.1 172.17.0.1 104.236.158.191] contain a domain component.  Your generated certs may fail TLS validation unless you only <span class="operator"><span class="keyword">use</span> one <span class="keyword">of</span> these shortnames <span class="keyword">or</span> IPs <span class="keyword">to</span> <span class="keyword">connect</span>.  You can <span class="keyword">use</span> the <span class="comment">--san flag to add more aliases</span></span><br><span class="line"></span><br><span class="line">You may enter additional aliases (SANs) <span class="keyword">now</span> <span class="keyword">or</span> press enter <span class="keyword">to</span> proceed <span class="keyword">with</span> the above <span class="keyword">list</span>.</span><br><span class="line">Additional aliases: abc</span><br><span class="line">INFO[<span class="number">0192</span>] Installing UCP <span class="keyword">with</span> host address <span class="number">104.236</span><span class="number">.158</span><span class="number">.191</span> - <span class="keyword">If</span> this <span class="keyword">is</span> incorrect, please specify an alternative address <span class="keyword">with</span> the <span class="string">'--host-address'</span> flag</span><br><span class="line">INFO[<span class="number">0000</span>] Checking that <span class="keyword">required</span> ports <span class="keyword">are</span> available <span class="keyword">and</span> <span class="keyword">accessible</span></span><br><span class="line">INFO[<span class="number">0005</span>] Generating UCP Cluster Root CA</span><br><span class="line">INFO[<span class="number">0047</span>] Generating UCP <span class="keyword">Client</span> Root CA</span><br><span class="line">INFO[<span class="number">0060</span>] Deploying UCP Containers</span><br><span class="line">INFO[<span class="number">0113</span>] <span class="keyword">New</span> configuration established.  Signalling the daemon <span class="keyword">to</span> <span class="keyword">load</span> it...</span><br><span class="line">INFO[<span class="number">0114</span>] Successfully delivered signal <span class="keyword">to</span> daemon</span><br><span class="line">INFO[<span class="number">0114</span>] UCP <span class="keyword">instance</span> <span class="keyword">ID</span>: DKVU:ULUA:C3SO:O36W:<span class="number">4</span>WUE:OM4Z:<span class="number">5</span>V4X:IA46:ZLS5:L2KE:KE5J:O56D</span><br><span class="line">INFO[<span class="number">0114</span>] UCP <span class="keyword">Server</span> SSL: <span class="keyword">SHA</span>-<span class="number">256</span> Fingerprint=<span class="number">71</span>:C8:<span class="number">1</span><span class="keyword">D</span>:AB:CA:EE:E7:<span class="number">91</span>:<span class="number">07</span>:D6:<span class="number">23</span>:<span class="number">83</span>:F2:A7:<span class="number">67</span>:<span class="number">2</span>A:F8:DE:<span class="number">88</span>:<span class="number">43</span>:<span class="number">5</span><span class="keyword">C</span>:D4:<span class="number">2</span><span class="keyword">E</span>:<span class="number">76</span>:<span class="number">9</span><span class="keyword">D</span>:BA:B9:<span class="number">39</span>:B4:<span class="number">11</span>:<span class="number">64</span>:<span class="number">86</span></span><br><span class="line">INFO[<span class="number">0114</span>] Login <span class="keyword">as</span> <span class="string">"admin"</span>/(your <span class="keyword">admin</span> <span class="keyword">password</span>) <span class="keyword">to</span> UCP <span class="keyword">at</span> https://<span class="number">104.236</span><span class="number">.158</span><span class="number">.191</span>:<span class="number">443</span></span></span><br></pre></td></tr></table></figure></p>
<p>安装完成，效果图<br><img src="https://cloud.githubusercontent.com/assets/5423628/17329710/6027e182-58f6-11e6-99cb-8f37aef00ccf.png" alt="效果图"></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="系统容器"><a href="#系统容器" class="headerlink" title="系统容器"></a>系统容器</h2><table>
<thead>
<tr>
<th>NODE</th>
<th>NAME</th>
<th>IMAGE</th>
<th>CREATED</th>
</tr>
</thead>
<tbody>
<tr>
<td>ubuntu-1gb-sfo1-01</td>
<td>ucp-controller</td>
<td>docker/ucp-controller:1.1.2</td>
<td>2016-08-02 20:30:12 +0800</td>
</tr>
<tr>
<td>ubuntu-1gb-sfo1-01</td>
<td>ucp-auth-worker</td>
<td>docker/ucp-auth:1.1.2</td>
<td>2016-08-02 20:30:09 +0800</td>
</tr>
<tr>
<td>ubuntu-1gb-sfo1-01</td>
<td>ucp-auth-api</td>
<td>docker/ucp-auth:1.1.2</td>
<td>2016-08-02 20:30:08 +0800</td>
</tr>
<tr>
<td>ubuntu-1gb-sfo1-01</td>
<td>ucp-auth-store</td>
<td>docker/ucp-auth-store:1.1.2</td>
<td>2016-08-02 20:30:04 +0800</td>
</tr>
<tr>
<td>ubuntu-1gb-sfo1-01</td>
<td>ucp-cluster-root-ca</td>
<td>docker/ucp-cfssl:1.1.2</td>
<td>2016-08-02 20:30:03 +0800</td>
</tr>
<tr>
<td>ubuntu-1gb-sfo1-01</td>
<td>ucp-client-root-ca</td>
<td>docker/ucp-cfssl:1.1.2</td>
<td>2016-08-02 20:30:02 +0800</td>
</tr>
<tr>
<td>ubuntu-1gb-sfo1-01</td>
<td>ucp-swarm-manager</td>
<td>docker/ucp-swarm:1.1.2</td>
<td>2016-08-02 20:30:01 +0800</td>
</tr>
<tr>
<td>ubuntu-1gb-sfo1-01</td>
<td>ucp-swarm-join</td>
<td>docker/ucp-swarm:1.1.2</td>
<td>2016-08-02 20:30:01 +0800</td>
</tr>
<tr>
<td>ubuntu-1gb-sfo1-01</td>
<td>ucp-proxy</td>
<td>docker/ucp-proxy:1.1.2</td>
<td>2016-08-02 20:29:59 +0800</td>
</tr>
<tr>
<td>ubuntu-1gb-sfo1-01</td>
<td>ucp-kv</td>
<td>docker/ucp-etcd:1.1.2</td>
<td>2016-08-02 20:29:56 +0800</td>
</tr>
</tbody>
</table>
<p><img src="https://docs.docker.com/ucp/images/architecture-3.png" alt="官网的架构图"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ucp-proxy</td>
<td>A TLS proxy. It allows secure access to the local Docker Engine.</td>
</tr>
<tr>
<td>ucp-controller</td>
<td>The UCP application. It uses the key-value store for persisting configurations.</td>
</tr>
<tr>
<td>ucp-swarm-manager</td>
<td>Provides the clustering capabilities. It uses the key-value store for leader election, and keeping track of cluster members.</td>
</tr>
<tr>
<td>ucp-swarm-join</td>
<td>Heartbeat to record on the key-value store that this node is alive. If the node goes down, this heartbeat stops, and the node is removed from the cluster.</td>
</tr>
<tr>
<td>ucp-auth-api</td>
<td>The centralized API for identity and authentication used by UCP and DTR.</td>
</tr>
<tr>
<td>ucp-auth-worker</td>
<td>Performs scheduled LDAP synchronizations and cleans data on the ucp-auth-store.</td>
</tr>
<tr>
<td>ucp-auth-store</td>
<td>Stores authentication configurations, and data for users, organizations and teams.</td>
</tr>
<tr>
<td>ucp-kv</td>
<td>Used to store the UCP configurations. Don’t use it in your applications, since it’s for internal use only.</td>
</tr>
<tr>
<td>ucp-cluster-root-ca</td>
<td>A certificate authority to sign the certificates used when joining new nodes, and on administrator client bundles.</td>
</tr>
<tr>
<td>ucp-client-root-ca</td>
<td>A certificate authority to sign user bundles. Only used when UCP is installed without an external root CA.</td>
</tr>
</tbody>
</table>
<p>基本上明白都有什么作用了</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;docker官方也有私有云版本&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="UCP" scheme="http://blog.decbug.com/tags/UCP/"/>
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes多租户分析</title>
    <link href="http://blog.decbug.com/2016/08/01/k8s_multi_tenant/"/>
    <id>http://blog.decbug.com/2016/08/01/k8s_multi_tenant/</id>
    <published>2016-07-31T17:00:00.000Z</published>
    <updated>2017-01-20T00:12:16.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公有云产品有个很重要的概念叫多租户，比如OpenStack的Domain/Project。提供资源隔离，权限控制，等等。<br>kubernetes如果作为PaaS的基础，那么也需要具备此能力。<br><a id="more"></a></p>
<h1 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h1><blockquote>
<p>Kubernetes supports multiple virtual clusters backed by the same physical cluster. These virtual clusters are called namespaces.</p>
</blockquote>
<p>一组逻辑的集群，可以大概类似于租户的概念，可以做到一定程度的资源隔离，Quota。如果非要和OpenStack做个映射，那么就大概对应于Project吧。</p>
<p>举个例子</p>
<ul>
<li>kubectl –namespace=abc run nginx –image=nginx</li>
<li>kubectl  run nginx –image=nginx<br>这两条命令虽然都是run起来一个nginx，但是作用域却不一样。命令1是在一个叫abc的namespace里运行nginx，命令2则是在Default</li>
</ul>
<h1 id="Resource-Quota"><a href="#Resource-Quota" class="headerlink" title="Resource Quota"></a>Resource Quota</h1><blockquote>
<p>A resource quota, defined by a ResourceQuota object, provides constraints that limit aggregate resource consumption per namespace.<br>限制某个name space的资源总数</p>
</blockquote>
<p>使用方法: It is enabled when the apiserver –admission-control= flag has ResourceQuota as one of its arguments</p>
<h2 id="Compute-Resource-Quota"><a href="#Compute-Resource-Quota" class="headerlink" title="Compute Resource Quota"></a>Compute Resource Quota</h2><table>
<thead>
<tr>
<th>Resource Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>cpu</td>
<td>Across all pods in a non-terminal state, the sum of CPU requests cannot exceed this value.</td>
</tr>
<tr>
<td>limits.cpu</td>
<td>Across all pods in a non-terminal state, the sum of CPU limits cannot exceed this value.</td>
</tr>
<tr>
<td>limits.memory</td>
<td>Across all pods in a non-terminal state, the sum of memory limits cannot exceed this value.</td>
</tr>
<tr>
<td>memory</td>
<td>Across all pods in a non-terminal state, the sum of memory requests cannot exceed this value.</td>
</tr>
<tr>
<td>requests.cpu</td>
<td>Across all pods in a non-terminal state, the sum of CPU requests cannot exceed this value.</td>
</tr>
<tr>
<td>requests.memory</td>
<td>Across all pods in a non-terminal state, the sum of memory requests cannot exceed this value.</td>
</tr>
</tbody>
</table>
<h2 id="Object-Count-Quota"><a href="#Object-Count-Quota" class="headerlink" title="Object Count Quota"></a>Object Count Quota</h2><table>
<thead>
<tr>
<th>Resource Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>configmaps</td>
<td>The total number of config maps that can exist in the namespace.</td>
</tr>
<tr>
<td>persistentvolumeclaims</td>
<td>The total number of persistent volume claims that can exist in the namespace.</td>
</tr>
<tr>
<td>pods</td>
<td>The total number of pods in a non-terminal state that can exist in the namespace. A pod is in a terminal state if status.phase in (Failed, Succeeded) is true.</td>
</tr>
<tr>
<td>replicationcontrollers</td>
<td>The total number of replication controllers that can exist in the namespace.</td>
</tr>
<tr>
<td>resourcequotas</td>
<td>The total number of resource quotas that can exist in the namespace.</td>
</tr>
<tr>
<td>services</td>
<td>The total number of services that can exist in the namespace.</td>
</tr>
<tr>
<td>services.loadbalancers</td>
<td>The total number of services of type load balancer that can exist in the namespace.</td>
</tr>
<tr>
<td>services.nodeports</td>
<td>The total number of services of type node port that can exist in the namespace.</td>
</tr>
<tr>
<td>secrets</td>
<td>The total number of secrets that can exist in the namespace.</td>
</tr>
</tbody>
</table>
<p>对象的总数，比如限制最多可以创建几个pod，最多几个rc</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe quota compute-resources --<span class="keyword">namespace</span>=myspace</span><br><span class="line">Name:                  compute-resources</span><br><span class="line">Namespace:             myspace</span><br><span class="line">Resource               Used Hard</span><br><span class="line">--------               ---- ----</span><br><span class="line">limits.cpu             <span class="number">0</span>    <span class="number">2</span></span><br><span class="line">limits.memory          <span class="number">0</span>    <span class="number">2</span>Gi</span><br><span class="line">pods                   <span class="number">0</span>    <span class="number">4</span></span><br><span class="line">requests.cpu           <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">requests.memory        <span class="number">0</span>    <span class="number">1</span>Gi</span><br><span class="line"></span><br><span class="line">$ kubectl describe quota object-counts --<span class="keyword">namespace</span>=myspace</span><br><span class="line">Name:                   object-counts</span><br><span class="line">Namespace:              myspace</span><br><span class="line">Resource                Used    Hard</span><br><span class="line">--------                ----    ----</span><br><span class="line">configmaps              <span class="number">0</span>       <span class="number">10</span></span><br><span class="line">persistentvolumeclaims  <span class="number">0</span>       <span class="number">4</span></span><br><span class="line">replicationcontrollers  <span class="number">0</span>       <span class="number">20</span></span><br><span class="line">secrets                 <span class="number">1</span>       <span class="number">10</span></span><br><span class="line">services                <span class="number">0</span>       <span class="number">10</span></span><br><span class="line">services.loadbalancers  <span class="number">0</span>       <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="Limit-Range"><a href="#Limit-Range" class="headerlink" title="Limit Range"></a>Limit Range</h1><p>需要在Admission Controller启用LimitRanger插件</p>
<p>By default, pods run with unbounded CPU and memory limits.</p>
<p>Let’s create a simple limit in our namespace.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="operator"><span class="keyword">create</span> -<span class="keyword">f</span> docs/<span class="keyword">admin</span>/limitrange/limits.yaml <span class="comment">--namespace=limit-example</span></span><br><span class="line"></span><br><span class="line">limitrange <span class="string">"mylimits"</span> created</span></span><br></pre></td></tr></table></figure></p>
<p>Let’s describe the limits that we have imposed in our namespace.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="operator"><span class="keyword">describe</span> limits mylimits <span class="comment">--namespace=limit-example</span></span><br><span class="line"><span class="keyword">Name</span>:   mylimits</span><br><span class="line">Namespace:  <span class="keyword">limit</span>-example</span><br><span class="line"><span class="keyword">Type</span>        <span class="keyword">Resource</span>      <span class="keyword">Min</span>      <span class="keyword">Max</span>      <span class="keyword">Default</span> Request      <span class="keyword">Default</span> <span class="keyword">Limit</span>      <span class="keyword">Max</span> <span class="keyword">Limit</span>/Request Ratio</span><br><span class="line"><span class="comment">----        --------      ---      ---      ---------------      -------------      -----------------------</span></span><br><span class="line">Pod         cpu           <span class="number">200</span><span class="keyword">m</span>     <span class="number">2</span>        -                    -                  -</span><br><span class="line">Pod         <span class="keyword">memory</span>        <span class="number">6</span>Mi      <span class="number">1</span>Gi      -                    -                  -</span><br><span class="line"><span class="keyword">Container</span>   cpu           <span class="number">100</span><span class="keyword">m</span>     <span class="number">2</span>        <span class="number">200</span><span class="keyword">m</span>                 <span class="number">300</span><span class="keyword">m</span>               -</span><br><span class="line"><span class="keyword">Container</span>   <span class="keyword">memory</span>        <span class="number">3</span>Mi      <span class="number">1</span>Gi      <span class="number">100</span>Mi                <span class="number">200</span>Mi              -</span></span><br></pre></td></tr></table></figure></p>
<h1 id="ABAC"><a href="#ABAC" class="headerlink" title="ABAC"></a>ABAC</h1><p>限定某个用户能做的事情，比如<br>Alice can do anything to all resources:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">apiVersion</span>":<span class="value"><span class="string">"abac.authorization.kubernetes.io/v1beta1"</span></span>,</span><br><span class="line">    "<span class="attribute">kind</span>":<span class="value"><span class="string">"Policy"</span></span>,</span><br><span class="line">    "<span class="attribute">spec</span>":<span class="value">&#123;</span><br><span class="line">        "<span class="attribute">user</span>":<span class="value"><span class="string">"alice"</span></span>,</span><br><span class="line">        "<span class="attribute">namespace</span>":<span class="value"><span class="string">"*"</span></span>,</span><br><span class="line">        "<span class="attribute">resource</span>":<span class="value"><span class="string">"*"</span></span>,</span><br><span class="line">        "<span class="attribute">apiGroup</span>":<span class="value"><span class="string">"*"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>Bob can just read pods in namespace “projectCaribou”<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">apiVersion</span>":<span class="value"><span class="string">"abac.authorization.kubernetes.io/v1beta1"</span></span>,</span><br><span class="line">    "<span class="attribute">kind</span>":<span class="value"><span class="string">"Policy"</span></span>,</span><br><span class="line">    "<span class="attribute">spec</span>":<span class="value">&#123;</span><br><span class="line">        "<span class="attribute">user</span>":<span class="value"><span class="string">"bob"</span></span>,</span><br><span class="line">        "<span class="attribute">namespace</span>":<span class="value"><span class="string">"projectCaribou"</span></span>,</span><br><span class="line">        "<span class="attribute">resource</span>":<span class="value"><span class="string">"pods"</span></span>,</span><br><span class="line">        "<span class="attribute">readonly</span>":<span class="value"><span class="literal">true</span></span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>缺点是，必须在api server启动的时候就传入文件。如果需要对权限做修改，那么必须重启api server才能生效</p>
<h1 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h1><p>之前提到了ABAC比较弱，所以呢1.3出来个新特性，叫RBAC，目前还是Alpha。<br>从名字就能看出来<code>“RBAC” (Role-Based Access Control)</code>，基于角色，有点像OpenStack的角色了</p>
<h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kind</span>: Role</span><br><span class="line"><span class="attribute">apiVersion</span>: rbac.authorization.k8s.io/v1alpha1</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">namespace</span>: default</span><br><span class="line">  <span class="attribute">name</span>: pod-reader</span><br><span class="line"><span class="attribute">rules</span>:</span><br><span class="line">  - <span class="attribute">apiGroups</span>: [<span class="string">""</span>] # The API group <span class="string">""</span> indicates the default API Group.</span><br><span class="line">    <span class="attribute">resources</span>: [<span class="string">"pods"</span>]</span><br><span class="line">    <span class="attribute">verbs</span>: [<span class="string">"get"</span>, <span class="string">"watch"</span>, <span class="string">"list"</span>]</span><br><span class="line">    <span class="attribute">nonResourceURLs</span>: []</span><br></pre></td></tr></table></figure>
<h2 id="RolesBindings"><a href="#RolesBindings" class="headerlink" title="RolesBindings"></a>RolesBindings</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This role binding allows "jane" to read pods in the namespace "default"</span></span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1alpha1</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="operator">read</span>-pods</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">  - kind: <span class="keyword">User</span> <span class="title"># May</span> be <span class="string">"User"</span>, <span class="string">"Group"</span> <span class="operator">or</span> <span class="string">"ServiceAccount"</span></span><br><span class="line">    name: jane</span><br><span class="line">roleRef:</span><br><span class="line">  kind: <span class="keyword">Role</span></span><br><span class="line">  <span class="title">namespace</span>: default</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiVersion: rbac.authorization.k8s.io/v1alpha1</span><br></pre></td></tr></table></figure>
<h2 id="一图胜千言"><a href="#一图胜千言" class="headerlink" title="一图胜千言"></a>一图胜千言</h2><img src="http://www.plantuml.com/plantuml/svg/POux2e1034Jxd2BOMsmE8EWrP96eGKIDYujOY7VtZx2Ma_TcYEEguqOmKXx4Ewx4HCWUrHjS0JO0zpFeCUWMycdinTWuEJgGprwcz0ZNjIXRhLjjZ8KWFy89paPcCPxTl_NHUbmqu1Iiqhlw0hgUeXq0">
<p>userA和userB是通过<code>[role_binding1][role1]</code>连接到name space 1，得到在name space1进行操作的权限。<br>userB则是<code>[role_binding2]-&gt;[role2]</code>得到在name space2进行操作的权限。</p>
<h1 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h1><p>感觉很强大，是否可以和keystone对接？把OpenStack的多租户能力借鉴过来？</p>
<hr>
<p><code>本博客欢迎转发,但请保留原作者信息</code><br>github:<a href="https://github.com/CodeJuan" target="_blank" rel="external">codejuan</a><br>博客地址:<a href="http://blog.decbug.com/">http://blog.decbug.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;公有云产品有个很重要的概念叫多租户，比如OpenStack的Domain/Project。提供资源隔离，权限控制，等等。&lt;br&gt;kubernetes如果作为PaaS的基础，那么也需要具备此能力。&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://blog.decbug.com/categories/code/"/>
    
    
      <category term="docker" scheme="http://blog.decbug.com/tags/docker/"/>
    
      <category term="kubernetes" scheme="http://blog.decbug.com/tags/kubernetes/"/>
    
      <category term="multi-tenant" scheme="http://blog.decbug.com/tags/multi-tenant/"/>
    
  </entry>
  
</feed>
