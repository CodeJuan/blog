---
title: 各种锁:自旋锁/互斥锁/读写锁/分布式锁
date: 2016-04-29 00:00:00
categories:
- code
tags: 
- lock
mathjax: true
description: 
---

# 锁
锁在计算机的世界里随处可见，当大家都想操作一个资源的时候，如果一窝蜂涌进来，就会出事的。
举个例子，加入说有2个线程都在操作一个共享资源（一个int），给他+1。我们知道+1不是原子操作，所谓原子操作，就是如果这个操作开始执行了，那么就不会被打断。看过汇编的同学都知道，+1需要先mov然后在add，如线程1mov了，然后执行线程2的mov，就会出问题。轻则数据错误，重则程序崩溃。感觉这个例子不太恰当，还是领会精神吧。为了保护我们的操作，那么就需要使得这个共享资源的操作变成原子的，这就需要锁了。
在并发编程中，尽量少用锁，能不用就不用，因为锁的开销很大很大。尽量让不同的执行单元操作各自独立的数据，如果不可避免要用到锁，那么锁的范围要尽量小。


<!--more-->
# 自旋锁vs互斥锁

类|特征|使用场景
---|---|---
自旋|不会休眠，不停重试，直到获得锁|锁住的代码执行时间很短。因为休眠再唤醒的开销很大。如果时间短，那么自旋的开销就很小
互斥|休眠，等锁被释放才会被唤醒|锁住的代码要执行很久，如果是自旋锁，就会不停尝试，被锁住的代码分不到足够的时间片，但是性能下降

# 读写锁
场景：读多写少
条件：
- 只要没有写锁，就能获取到读锁
- 只有没有任锁，才能获取到写锁

----------------------------

`本博客欢迎转发,但请保留原作者信息`
github:[codejuan](https://github.com/CodeJuan)
博客地址:http://blog.decbug.com/
